#!/usr/bin/python3
"""
jouno: Journal notifications forwarder
======================================

A desktop journal-entry to desktop-notification forwarder.

Usage:
======

        jouno [-h]
                     [--about] [--detailed-help]
                     [--install] [--uninstall]

Optional arguments:
-------------------

      -h, --help            show this help message and exit
      --detailed-help       full help in markdown format
      --about               about jouno
      --install             installs the jouno in the current user's path and desktop application menu.
      --uninstall           uninstalls the jouno application menu file and script for the current user.

Description
===========

``jouno`` A desktop journal-entry to desktop-notification forwarder with a range of filtering capabilities.
The systemd-journal is continuously monitored for new entries which are then filtered to select those that
need to be forwarded to the standard ``freedesktop`` ``dbus`` notifications interface.  Bursts of messages
are handled by bundling them in to single summarising notification.

``jouno`` runs as a system-tray application.

Configuration
=============

Clicking on the ``jouno`` system-tray icon brings up an ``options and filters`` panel which includes three
tabs:

  1. Options: settings that adjust how to display messages and how to collate of bursts af messages

  2. Match Filters: filters that restrict notifications to only journal entries they match.

  3. Ignore Filters: filters that restrict notifications by ignoring journal entries they match.

Match filtering is most useful when only minimal journal entries are of interest and the other entries aren't
of interest.  For example, a match-filter might be set for core-dump journal entries only.

Ignore filtering is most useful when almost any journal entries might be of interest and only a few journal
items need to be ignored.  For example, if any unexpected messages might be of interest, ignore-filters could
be set up for any that are routine.

It's common to require a few ignore-filters to discard any messages generated by the desktop notification system
in response to notices being posted.


Config files
------------------------------------

The config files are in INI-format divided into a number of sections as outlined below:

        # The options section controls notice timeouts, burst treatment
        [options]
        # Wait at lease burst_seconds before declaring a burst of messages to have finished
        burst_seconds = 2
        # Only show the the first burst_truncate_messages of a burst
        burst_truncate_messages = 3
        # Set journo messages to timeout/auto-dismiss after notification-seconds
        notification_seconds = 30
        # For debugging the application
        debug = yes

        [match]
        # Each filter rule has an id and the message text to match
        my_rule_id = forward journal entry if this string matches
        # Each filter rule can be disabled by a corresponding my_rule_id_enabled = no option
        my_rule_id_enabled = no
        # A filter id that ends in _regexp is treated as a python regular-expression
        my_other_rule_id_regexp = forward journal [Ee]ntry if this python-regexp matches

        [ignore]
        my_ignore_rule_id = ignore journal entry if this string matches
        my_ignore_other_rule_id_regexp = ignore [Jj]ournal entry if this python-regexp matches

The config files are optional, but some filtering of the journal is likely to be necessary.
``jouno`` copes with cascades and won't cause infinite cascades, but filtering may be necessary
to eliminate excessive bursts caused by the desktop when it processes the notifications generated
by jouno.


Responsiveness
--------------

I've logged a bug against the KDE plasma notifications. Generating multiple messages with expiry timeouts
cause plasma-notifications and the kwin-x11 to cosume a large amount of CPU and become jerky when dragging
windows.  This doesn't seem to happen if notices do not expire (``notification_seconds = 0``).  This
isn't a bug confined to jouno generated notifications, it can be reproduced by normal shell commands,
for example:

  for i in 1 2 3 4 5 6 7 8 9 10; do notify-send --expire-time 30 test $i;done

The problem can be reduced by using sufficient match/ignore filters or by turning off notification
expiry by setting ``notification_seconds = 0``

Examples
========

    jouno
        All default controls.



Prerequisites
=============

Described for OpenSUSE, similar for other distros:

Software::

        zypper install python38-QtPy python38-systemd


jouno Copyright (C) 2021 Michael Hamilton
===========================================

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, version 3.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along
with this program. If not, see <https://www.gnu.org/licenses/>.

**Contact:**  m i c h a e l   @   a c t r i x   .   g e n   .   n z

----------

"""

import configparser
import os
import pickle
import re
import select
import traceback
from enum import Enum
from pathlib import Path
from typing import Mapping, Any, List, Type
import signal
import sys
import multiprocessing as mp

from PyQt5.QtCore import QCoreApplication, QProcess, Qt, QPoint, QAbstractTableModel, QModelIndex, QRegExp
from PyQt5.QtGui import QPixmap, QIcon, QImage, QPainter, QCursor, QStandardItemModel, QStandardItem, QIntValidator, \
    QRegExpValidator, QHideEvent
from PyQt5.QtSvg import QSvgWidget, QSvgRenderer
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QHBoxLayout, QSlider, QMessageBox, QLineEdit, QLabel, \
    QSplashScreen, QPushButton, QProgressBar, QComboBox, QSystemTrayIcon, QMenu, QStyle, QTextEdit, QDialog, QTabWidget, \
    QCheckBox, QPlainTextEdit, QGridLayout, QSizePolicy, QAction, QTableWidget, QTableWidgetItem, QTableView, \
    QAbstractItemView, QHeaderView, QStyledItemDelegate
import dbus
from systemd import journal

DEFAULT_CONFIG = '''
[options]
burst_seconds = 2
burst_truncate_messages = 3
notification_seconds = 60
debug_enabled = yes

[ignore] 
kwin_bad_damage = XCB error: 152 (BadDamage)
kwin_bad_window = kwin_core: XCB error: 3 (BadWindow)
self_caused = NotificationPopup.
qt_kde_binding_loop = Binding loop detected for property

[match]

'''

# ######################## MONITOR SUB PROCESS CODE ###############################################################


class Priority(Enum):
    EMERGENCY = 0
    ALERT = 1
    CRITICAL = 2
    ERR = 3
    WARNING = 4
    NOTICE = 5
    INFO = 6
    DEBUG = 7


NOTIFICATION_ICONS = {
    Priority.EMERGENCY: 'dialog-error.png',
    Priority.ALERT: 'dialog-error.png',
    Priority.CRITICAL: 'dialog-error.png',
    Priority.ERR: 'dialog-error.png',
    Priority.WARNING: 'dialog-warning.png',
    Priority.NOTICE: 'dialog-information.png',
    Priority.INFO: 'dialog-information.png',
    Priority.DEBUG: 'dialog-information.png',
}

debug_enabled = True


def debug(*arg):
    if debug_enabled:
        print('DEBUG:', *arg)


def info(*arg):
    print('INFO:', *arg)


class NotifyFreeDesktop:

    def __init__(self):
        self.notify_interface = dbus.Interface(
            object=dbus.SessionBus().get_object("org.freedesktop.Notifications", "/org/freedesktop/Notifications"),
            dbus_interface="org.freedesktop.Notifications")

    def notify_desktop(self, app_name: str, summary: str, message: str, priority: Priority, timeout: int):
        # https://specifications.freedesktop.org/notification-spec/notification-spec-latest.html
        replace_id = 0
        notification_icon = NOTIFICATION_ICONS[priority]
        action_requests = []
        # extra_hints = {"urgency": 1, "sound-name": "dialog-warning", }
        extra_hints = {}
        self.notify_interface.Notify(app_name, replace_id, notification_icon, summary, message, action_requests,
                                     extra_hints,
                                     timeout)


def get_config_path() -> Path:
    config_dir_path = Path.home().joinpath('.config').joinpath('jouno')
    if not config_dir_path.parent.is_dir():
        os.makedirs(config_dir_path)
    path = config_dir_path.joinpath('jouno.conf')
    return path


class Config(configparser.ConfigParser):

    def __init__(self):
        super().__init__()
        self.path = get_config_path()
        self.modified_time = 0.0
        self.read_string(DEFAULT_CONFIG)

    def save(self):
        with open(self.path, 'w') as config_file:
            self.write(config_file)

    def refresh(self) -> bool:
        if self.path.is_file():
            modified_time = self.path.lstat().st_mtime
            if self.modified_time == modified_time:
                return False
            self.modified_time = modified_time
            info(f"Reading {self.path}")
            config_text = self.path.read_text()
            for section in ['options', 'match', 'ignore']:
                self.remove_section(section)
            self.read_string(config_text)
            for section in ['options', 'match', 'ignore']:
                if section not in self:
                    self[section] = {}
            return True
        if self.modified_time > 0.0:
            info(f"Config file has been deleted: {self.path}")
            self.modified_time = 0.0
        return False


class JournalWatcher:

    def __init__(self):
        self.config: Config = None
        self.burst_truncate: int = 3
        self.polling_millis: int = 2000
        self.notification_timeout: int = 60000
        self.ignore_regexp: Mapping[str, re] = {}
        self.match_regexp: Mapping[str, re] = {}
        self.update_config()

    def update_config(self):
        if self.config is None:
            self.config = Config()
        if not self.config.refresh():
            return
        if 'burst_truncate_messages' in self.config['options']:
            self.burst_truncate = self.config.getint('options', 'burst_truncate_messages')
        if 'burst_seconds' in self.config['options']:
            self.polling_millis = 1000 * self.config.getint('options', 'burst_seconds')
        if 'notification_seconds' in self.config['options']:
            self.notification_timeout = 1000 * self.config.getint('options', 'notification_seconds')
        if 'debug' in self.config['options']:
            global debug_enabled
            debug_enabled = self.config.getboolean('options', 'debug')
        self.ignore_regexp: Mapping[str, re] = {}
        self.match_regexp: Mapping[str, re] = {}
        self.compile_patterns(self.config['match'], self.match_regexp)
        self.compile_patterns(self.config['ignore'], self.ignore_regexp)

    def compile_patterns(self, rules_map: Mapping[str, str], patterns_map: Mapping[str, re.Pattern]):
        for rule_id, rule_text in rules_map.items():
            if rule_id.endswith('_enabled'):
                pass
            else:
                rule_enable_key = rule_id + "_enabled"
                if rule_enable_key not in rules_map or rules_map[rule_enable_key] == 'yes':
                    debug(f"including {rule_id}")
                    if rule_id.endswith('_regexp'):
                        patterns_map[rule_id] = re.compile(rule_text)
                    else:
                        patterns_map[rule_id] = re.compile(re.escape(rule_text))

    def determine_app_name(self, journal_entries: List[Mapping[str, Any]]):
        app_name_info = ''
        sep = '\u25b3'
        for journal_entry in journal_entries:
            for key, prefix in {'_CMDLINE': '', '_EXE': '', '_COMM': '', 'SYSLOG_IDENTIFIER': '',
                                '_KERNEL_SUBSYSTEM': 'kernel ',
                                }.items():
                print(key, journal_entry[key] if key in journal_entry else False)
                if key in journal_entry:
                    value = str(journal_entry[key])
                    if app_name_info.find(value) < 0:
                        app_name_info += sep + prefix + value
                        sep = '; '
        if app_name_info == '':
            app_name_info = sep + 'unknown'
        return app_name_info

    def determine_summary(self, journal_entries: List[Mapping[str, Any]]):
        journal_entry = journal_entries[0]
        realtime = journal_entry['__REALTIME_TIMESTAMP']
        transport = f" {journal_entry['_TRANSPORT']}" if '_TRANSPORT' in journal_entry else ''
        number_of_entries = len(journal_entries)
        if number_of_entries > 1:
            summary = f"\u25F4{realtime:%H:%M:%S}:{transport} Burst of {number_of_entries} messages"
        else:
            text = ''
            sep = ''
            for key, prefix in {'SYSLOG_IDENTIFIER': '', '_PID': 'PID ', '_KERNEL_SUBSYSTEM': 'kernel ', }.items():
                if key in journal_entry:
                    value = str(journal_entry[key])
                    if text.find(value) < 0:
                        text += sep + prefix + value
                        sep = ' '
            summary = f"\u25F4{realtime:%H:%M:%S}: {text} (\u21e8{transport})"
        debug(f"realtime='{realtime}' summary='{summary}'")
        return summary

    def determine_message(self, journal_entries: List[Mapping[str, Any]]) -> str:
        message = ''
        sep = ''
        previous_message = ''
        duplicates = 0
        reported = 0
        for journal_entry in journal_entries:
            new_message = journal_entry['MESSAGE']
            if new_message == previous_message:
                duplicates += 1
            else:
                message += f"{sep}\u25B7{new_message}"
                previous_message = new_message
                reported += 1
                if reported == self.burst_truncate and reported < len(journal_entries):
                    message += f"\n[Only showing first {self.burst_truncate} messages]"
                    break
            sep = '\n'
        if duplicates > 0:
            message += f'\n[{duplicates + 1} duplicate messages]'
        debug(f'message={message}')
        return message

    def determine_priority(self, journal_entries: List[Mapping[str, Any]]) -> Priority:
        current_level = Priority.NOTICE
        for journal_entry in journal_entries:
            if 'PRIORITY' in journal_entry:
                priority = journal_entry['PRIORITY']
                if priority < current_level.value and (Priority.EMERGENCY.value <= priority <= Priority.DEBUG.value):
                    current_level = Priority(priority)
        return current_level

    def is_notable(self, journal_entry: Mapping[str, Any]):
        message = journal_entry['MESSAGE']
        if message != "":
            for rule_id, match_re in self.match_regexp.items():
                if match_re.search(message) is not None:
                    debug(f"rule=match.{rule_id}: {message}")
                    return True
            for rule_id, ignore_re in self.ignore_regexp.items():
                if ignore_re.search(message) is not None:
                    debug(f"rule=ignore.{rule_id}: {message}")
                    return False
        return len(self.match_regexp) == 0

    def watch_journal(self):
        notify = NotifyFreeDesktop()

        journal_reader = journal.Reader()
        # #j.log_level(journal.LOG_INFO)
        #
        # # j.add_match(_SYSTEMD_UNIT="systemd-udevd.service")
        journal_reader.seek_tail()
        journal_reader.get_previous()
        # j.get_next() # it seems this is not necessary.

        journal_reader_poll = select.poll()
        journal_reader_poll.register(journal_reader, journal_reader.get_events())
        journal_reader.add_match()
        while True:
            self.update_config()
            burst_count = 0
            notable = []
            while journal_reader_poll.poll(self.polling_millis):
                if journal_reader.process() == journal.APPEND:
                    for journal_entry in journal_reader:
                        burst_count += 1
                        if self.is_notable(journal_entry):
                            debug(f"Notable: burst_count={len(notable)}: {journal_entry}")
                            debug(f"Notable: burst_count={len(notable)}: {journal_entry['MESSAGE']}")
                            notable.append(journal_entry)
            if len(notable):
                notify.notify_desktop(app_name=self.determine_app_name(notable),
                                      summary=self.determine_summary(notable),
                                      message=self.determine_message(notable),
                                      priority=self.determine_priority(notable),
                                      timeout=self.notification_timeout)


def translate(source_text: str):
    """For future internationalization - recommended way to do this at this time."""
    return QCoreApplication.translate('vdu_controls', source_text)


# ######################## USER INTERFACE CODE ######################################################################

jouno_VERSION = '0.9.0'

ABOUT_TEXT = f"""

<b>jouno version {jouno_VERSION}</b>
<p>
A journal-entry to desktop-notification forwarder. 
<p>
<i>Right-mouse &rarr; context-menu &rarr; help</i> for help.
<p>
Visit <a href="https://github.com/digitaltrails/jouno">https://github.com/digitaltrails/jouno</a> for 
more details.
<p><p>

<b>jouno Copyright (C) 2021 Michael Hamilton</b>
<p>
This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, version 3.
<p>
This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
more details.
<p>
You should have received a copy of the GNU General Public License along
with this program. If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.

"""

CONTRAST_SVG = b"""
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 24 24" width="24" height="24">
  <defs>
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text { color:#232629; }
    </style>
  </defs>
  <g transform="translate(1,1)">
    <path style="fill:currentColor;fill-opacity:1;stroke:none" transform="translate(-1,-1)" d="m 12,7 c -2.761424,0 -5,2.2386 -5,5 0,2.7614 2.238576,5 5,5 2.761424,0 5,-2.2386 5,-5 0,-2.7614 -2.238576,-5 -5,-5 z m 0,1 v 8 C 9.790861,16 8,14.2091 8,12 8,9.7909 9.790861,8 12,8" class="ColorScheme-Text" id="path79" />
  </g>
</svg>
"""

# https://www.svgrepo.com/svg/335387/filter
FILTER_SVG_OLD = b"""
<svg width="24px" height="24px" viewBox="0 -1 18 19" xmlns="http://www.w3.org/2000/svg">
  <path fill="#494c4e" d="M14.35 4.855L10 9.21v2.8c0 1.31-2 2.45-2 1.89V9.2L3.65 4.856a.476.476 0 0 1-.11-.54A.5.5 0 0 1 4 4h10a.5.5 0 0 1 .46.31.476.476 0 0 1-.11.545z"/>
  <circle fill="#494c4e" cx="9" cy="17" r="1"/>
  <circle fill="#494c4e" cx="5" cy="1" r="1"/>
  <circle fill="#494c4e" cx="13" cy="1" r="1"/>
  <circle fill="#494c4e" cx="9" cy="1" r="1"/>
</svg>
"""

FILTER_SVG = b"""
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
      d="M 4 2 L 4 3 L 13 3 L 13 13 L 4 13 L 4 14 L 13 14 L 14 14 L 14 3 L 14 2 L 7 2 z M 8 6 L 8 8 L 12 8 L 12 7 L 8 7 z M 8 8 L 8 10 L 12 10 L 12 9 L 8 9 z M 8 11 L 8 12 L 12 12 L 12 11 L 10 11 z "
      class="ColorScheme-Text"
     />
</svg>
"""
# d="M 4 2 L 4 3 L 13 3 L 13 13 L 4 13 L 4 14 L 13 14 L 14 14 L 14 3 L 14 2 L 7 2 z M 7 6 L 7 8 L 12 8 L 12 7 L 7 7 z M 8 8 L 8 10 L 12 10 L 12 9 L 8 9 z M 9 11 L 9 12 L 12 12 L 12 11 L 10 11 z "
# d = "M 4 2 L 4 3 L 13 3 L 13 13 L 4 13 L 4 14 L 13 14 L 14 14 L 14 3 L 14 2 L 7 2 z M 7 6 L 7 7 L 12 7 L 12 6 L 7 6 z M 8 8 L 8 9 L 12 9 L 12 8 L 8 8 z M 9 10 L 9 11 L 12 11 L 12 10 L 10 10 z "

WINDOW_ICON_SVG = FILTER_SVG.replace(b'color:#232629;', b'color:#bbbbbb;')

FILTER_OFF_SVG_OLD = b"""
<svg width="24px" height="24px" viewBox="0 -1 18 19" xmlns="http://www.w3.org/2000/svg">
  <path fill="#da4453" d="M14.35 4.855L10 9.21v2.8c0 1.31-2 2.45-2 1.89V9.2L3.65 4.856a.476.476 0 0 1-.11-.54A.5.5 0 0 1 4 4h10a.5.5 0 0 1 .46.31.476.476 0 0 1-.11.545z"/>
  <circle fill="#494c4e" cx="5" cy="1" r="1"/>
  <circle fill="#494c4e" cx="13" cy="1" r="1"/>
  <circle fill="#494c4e" cx="9" cy="1" r="1"/>
</svg>
"""

FILTER_OFF_SVG = b"""
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      .ColorScheme-NegativeText {
        color:#da4453;
      }
      </style>
  </defs>
  <path
     style="fill:currentColor;fill-opacity:1;stroke:none" 
     class="ColorScheme-NegativeText"
    d="M 8 2 A 6 5.9999852 0 0 0 4.5273438 3.1132812 L 5.2460938 3.8320312 A 5 5 0 0 1 8 3 A 5 5 0 0 1 13 8 A 5 5 0 0 1 12.167969 10.753906 L 12.884766 11.470703 A 6 5.9999852 0 0 0 14 8 A 6 5.9999852 0 0 0 8 2 z M 3.1152344 4.5292969 A 6 5.9999852 0 0 0 2 8 A 6 5.9999852 0 0 0 8 14 A 6 5.9999852 0 0 0 11.472656 12.886719 L 10.753906 12.167969 A 5 5 0 0 1 8 13 A 5 5 0 0 1 3 8 A 5 5 0 0 1 3.8320312 5.2460938 L 3.1152344 4.5292969 z M 5 7 L 5 9 L 11 9 L 11 7 L 5 7 z "
          />
</svg>
"""


def create_icon_from_svg_string(svg_str: bytes) -> QIcon:
    """There is no QIcon option for loading SVG from a string, only from a SVG file, so roll our own."""
    renderer = QSvgRenderer(svg_str)
    image = QImage(64, 64, QImage.Format_ARGB32)
    image.fill(0x0)
    painter = QPainter(image)
    renderer.render(painter)
    painter.end()
    return QIcon(QPixmap.fromImage(image))


class OptionsTab(QWidget):

    def __init__(self, config_section: Mapping[str, str]):
        super().__init__()
        default_config = configparser.ConfigParser()
        default_config.read_string(DEFAULT_CONFIG)
        self.option_map: Mapping[str, QWidget] = {}
        layout = QGridLayout(self)
        row_number = 0
        for option_id, value in default_config['options'].items():
            label_widget = QLabel(translate(option_id))
            if option_id.endswith("_enabled"):
                input_widget = QCheckBox()
                input_widget.setChecked(value == 'yes')
            else:
                input_widget = QLineEdit()
                input_widget.setValidator(QIntValidator(0, 60))
                input_widget.setMaximumWidth(100)
                input_widget.setText(value)
            layout.addWidget(label_widget, row_number, 0)
            layout.addWidget(input_widget, row_number, 1, 1, 2, alignment=Qt.AlignLeft)
            self.option_map[option_id] = input_widget
            row_number += 1
        # Add a spacer to force those above to scrunch up.
        layout.addWidget(QWidget(), row_number, 1, 2, 2, alignment=Qt.AlignLeft)
        self.setLayout(layout)

    def copy_from_config(self, config_section: Mapping[str, str]):
        for option_id, widget in self.option_map.items():
            if option_id in config_section:
                if option_id.endswith("_enabled"):
                    widget.setChecked(config_section[option_id].lower() == "yes")
                else:
                    widget.setText(config_section[option_id])

    def copy_to_config(self, config_section: Mapping[str, str]):
        for option_id, widget in self.option_map.items():
            if option_id.endswith("_enabled"):
                config_section[option_id] = "yes" if widget.isChecked() else "no"
            else:
                if widget.text().strip() != "":
                    config_section[option_id] = widget.text()


class FilterPanel(QWidget):

    def __init__(self, config_section: Mapping[str, str]):
        super().__init__()
        print("table", str(config_section.keys()))
        self.table_view = FilterTableView(config_section)

        def add_action():
            self.table_view.append_new_config_rule()

        def del_action():
            self.table_view.delete_selected_rows()

        button_box = QWidget()
        button_box_layout = QHBoxLayout()
        add_button = QPushButton(translate("Add rule"))
        add_button.setToolTip("Add a new row above the selected row or at the end if no row is selected.\n"
                              "Click in the left margin to select a row.")
        add_button.clicked.connect(add_action)
        button_box_layout.addWidget(add_button)
        del_button = QPushButton(translate("Delete rules"))
        del_button.setToolTip("Remove selected rows. Click in the left margin to select some rows.")
        del_button.clicked.connect(del_action)
        button_box_layout.addWidget(del_button)
        button_box.setLayout(button_box_layout)

        layout = QVBoxLayout(self)
        layout.addWidget(self.table_view)
        layout.addWidget(button_box)
        self.setLayout(layout)

    def is_valid(self):
        return self.table_view.is_valid()

    def copy_from_config(self, config_section: Mapping[str, str]):
        self.table_view.copy_from_config(config_section)

    def copy_to_config(self, config_section: Mapping[str, str]):
        self.table_view.copy_to_config(config_section)


class FilterTableModel(QStandardItemModel):

    def __init__(self, number_of_rows: int):
        super().__init__(number_of_rows, 3)
        # use spaces to force a wider column - seems to be no other EASY way to do this.
        self.setHorizontalHeaderLabels(
            [translate("Enable"), translate("          Rule ID          "), translate("Pattern")])

# class ColumnItemDelegate(QStyledItemDelegate):
#     def createEditor(self, widget, option, index):
#         if not index.isValid():
#             return 0
#         if index.column() == 0: #only on the cells in the first column
#             editor = QLineEdit(widget)
#             validator = QRegExpValidator(QRegExp("\d{11}"), editor)
#             editor.setValidator(validator)
#             return editor
#         return super(ColumnItemDelegate, self).createEditor(widget, option, index)

class FilterValidationException(Exception):
    pass

class FilterTableView(QTableView):

    def __init__(self, config_section: Mapping[str, str]):
        super().__init__()
        self.setModel(FilterTableModel(len(config_section)))
        self.copy_from_config(config_section)
        self.setEditTriggers(QAbstractItemView.AllEditTriggers)
        self.verticalHeader().setSectionsMovable(True)
        self.verticalHeader().setDragEnabled(True)
        self.verticalHeader().setDragDropMode(QAbstractItemView.InternalMove)
        self.setDragDropOverwriteMode(True)
        self.resizeColumnsToContents()
        self.setToolTip(translate("To delete any rows, empty their Rule ID cells before clicking Apply."))
        self.setSelectionMode(QAbstractItemView.MultiSelection)
        # self.setItemDelegateForColumn(1, ColumnItemDelegate())
        self.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)

    def item_view_order(self) -> List[int]:
        """
        Walk the table model's rows in model-order of 1..n, find the current y-location or each row,
        sort the y-locations to determine the current view ordering of the model's rows (which may
        no longer be 1..n due to drag and drop).  Return a list of the current view ordering, for
        example [4, 0, 1, 2, 3].
        """
        # If there is no access to the rowCount, rowViewportPosition() can be called
        # until it returns -1 (note it can return other valid negative values, so just test
        # for -1.
        row_y_positions = []
        debug(f"row count={self.model().rowCount()}")
        for row_num in range(self.model().rowCount()):
            y = self.rowViewportPosition(row_num)
            row_y_positions.append((y, row_num))
        row_y_positions.sort()
        return [row_num for _, row_num in row_y_positions]

    def copy_from_config(self, config_section: Mapping[str, str]):
        model = self.model()
        if model.rowCount() > 0:
            model.removeRows(0, model.rowCount())
        row = 0
        enable_item_map: Mapping[str, QStandardItem] = {}
        # Step one - first gather the patterns and create a row for each one
        for key, value in config_section.items():
            if key.endswith("_enabled"):
                pass
            else:
                enable_item = self.create_checkable_item()
                enable_item_map[key + "_enabled"] = enable_item
                model.setItem(row, 0, enable_item)
                key_item = QStandardItem(key)
                key_item.setToolTip(
                    translate("A valid ID is a letter followed by letters, digits, underscores and hyphens\n") +
                    translate("An ID with a _regexp suffix denotes its pattern to be a regular expression"))
                model.setItem(row, 1, key_item)
                value_item = QStandardItem(value)
                value_item.setToolTip("Text or regexp to match in the journal message field.")
                model.setItem(row, 2, QStandardItem(value_item))
                row += 1
        # Step two - check if any patterns should be disabled and toggle the appropriate checkable.
        for enable_key, enable_item in enable_item_map.items():
            if enable_key in config_section:
                if config_section[enable_key].strip() == 'yes':
                    enable_item.setCheckState(Qt.Unchecked)

    def create_checkable_item(self):
        enable_item = QStandardItem()
        enable_item.setCheckable(True)
        enable_item.setCheckState(Qt.Checked)
        enable_item.setToolTip(translate("Enable/Disable"))
        return enable_item

    def is_valid(self) -> bool:
        model = self.model()
        for row_num in self.item_view_order():
            key = model.item(row_num, 1).text()
            value = model.item(row_num, 2).text()
            if re.fullmatch("[a-zA-Z]([a-zA-Z0-9_-])*", key) is None:
                raise FilterValidationException(
                        self.__class__.__name__, "Invalid rule ID", f"ID='{key}'")
            if key.endswith("_enabled"):
                pass
            elif key.endswith("_regexp"):
                try:
                    re.compile(value)
                except Exception as e:
                    raise FilterValidationException(
                        self.__class__.__name__, "Invalid Regular Expression", f"\n{key}={value}\n\n{str(e)}")
        return True

    def copy_to_config(self, config_section: Mapping[str, str]):
        debug(f'table order = {self.item_view_order()} ')
        for key in config_section.keys():
            del config_section[key]
        model = self.model()
        for row_num in self.item_view_order():
            key = model.item(row_num, 1).text()
            if key.strip() == '':
                continue
            value = model.item(row_num, 2).text()
            config_section[key] = value
            if model.item(row_num, 0).checkState() == Qt.Unchecked:
                config_section[key + "_enabled"] = "no"

    def append_new_config_rule(self):
        model = self.model()
        enable_item = self.create_checkable_item()
        selected_row_indices = self.selectionModel().selectedRows()
        if len(selected_row_indices) > 0:
            index = sorted(selected_row_indices)[0]
            model.insertRow(index.row(), [enable_item, QStandardItem(''), QStandardItem('')])
        else:
            self.model().appendRow([enable_item, QStandardItem(''), QStandardItem('')])

    def delete_selected_rows(self):
        model = self.model()
        selected_row_indices = self.selectionModel().selectedRows()
        if len(selected_row_indices) == 0:
            message = QMessageBox(self)
            message.setWindowTitle(translate('Delete'))
            message.setText(
                translate("Cannot delete, no rows selected.\nClick in the left margin to select some rows."))
            message.setIcon(QMessageBox.Critical)
            message.setStandardButtons(QMessageBox.Ok)
            message.exec()
            return
        # Reverse the order so we delete from bottom up preserving the positions of yet to be removed rows.
        for index in sorted(selected_row_indices, reverse=True):
            model.removeRow(index.row())

class ConfigEditorWidget(QWidget):

    def __init__(self):
        super().__init__()
        self.setWindowTitle(translate('Control Panel'))
        self.setMinimumWidth(1024)
        self.setMinimumHeight(720)
        layout = QVBoxLayout()
        self.setLayout(layout)
        tabs = QTabWidget()
        layout.addWidget(tabs)

        config = Config()
        config.refresh()
        options_panel = OptionsTab(config['options'])
        tabs.addTab(options_panel, "Options")
        match_panel = FilterPanel(config['match'])
        tabs.addTab(match_panel, "Match Filters")
        ignore_panel = FilterPanel(config['ignore'])
        tabs.addTab(ignore_panel, "Ignore Filters")
        self.setContextMenuPolicy(Qt.CustomContextMenu)

        button_box = QWidget()
        button_box_layout = QHBoxLayout()
        button_box.setLayout(button_box_layout)
        apply_button = QPushButton(translate("Apply"))
        revert_button = QPushButton(translate("Revert"))

        button_box_layout.addWidget(apply_button)
        button_box_layout.addWidget(revert_button)

        def save_action():
            debug("Apply")
            try:
                if match_panel.is_valid() and ignore_panel.is_valid():
                    options_panel.copy_to_config(config['options'])
                    match_panel.copy_to_config(config['match'])
                    ignore_panel.copy_to_config(config['ignore'])
                    config.save()
                    debug(f'ok')
            except FilterValidationException as e:
                title, summary, text = e.args
                message = QMessageBox(self)
                message.setWindowTitle(title)
                message.setText(f"{translate('Cannot apply changes.')}\n{summary}\n{text}")
                message.setIcon(QMessageBox.Critical)
                message.setStandardButtons(QMessageBox.Ok)
                # message.setDetailedText()
                message.exec()


        apply_button.clicked.connect(save_action)

        def revert_action():
            debug("revert")
            before = pickle.dumps(config)
            tmp = pickle.loads(before)
            options_panel.copy_to_config(tmp['options'])
            match_panel.copy_to_config(tmp['match'])
            ignore_panel.copy_to_config(tmp['ignore'])
            after = pickle.dumps(tmp)
            if before == after:
                revert_message = QMessageBox(self)
                revert_message.setText(translate('There are no unapplied changes, there is nothing to revert.'))
                revert_message.setIcon(QMessageBox.Warning)
                revert_message.setStandardButtons(QMessageBox.Ok)
                revert_message.exec()
                return
            else:
                revert_message = QMessageBox(self)
                revert_message.setText(translate('There are unapplied changes, revert and loose all changes?'))
                revert_message.setIcon(QMessageBox.Question)
                revert_message.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
                if revert_message.exec() == QMessageBox.Cancel:
                    return
            info("reverting unsaved edits")
            options_panel.copy_from_config(config['options'])
            match_panel.copy_from_config(config['match'])
            ignore_panel.copy_from_config(config['ignore'])

        revert_button.clicked.connect(revert_action)

        layout.addWidget(button_box)

        options_panel.copy_from_config(config['options'])
        match_panel.copy_from_config(config['match'])
        ignore_panel.copy_from_config(config['ignore'])
        # self.make_visible()

    def make_visible(self):
        """
        If the dialog exists(), call this to make it visible by raising it.
        Internal, used by the class method show_existing_dialog()
        """
        self.show()
        self.raise_()
        self.activateWindow()


class DialogSingletonMixin:
    """
    A mixin that can augment a QDialog or QMessageBox with code to enforce a singleton UI.
    For example, it is used so that only ones settings editor can be active at a time.
    """
    _dialogs_map = {}
    debug = False

    def __init__(self) -> None:
        """Registers the concrete class as a singleton so it can be reused later."""
        super().__init__()
        class_name = self.__class__.__name__
        if class_name in DialogSingletonMixin._dialogs_map:
            raise TypeError(f"ERROR: More than one instance of {class_name} cannot exist.")
        if DialogSingletonMixin.debug:
            print(f'DEBUG: SingletonDialog created for {class_name}')
        DialogSingletonMixin._dialogs_map[class_name] = self

    def closeEvent(self, event) -> None:
        """Subclasses that implement their own closeEvent must call this closeEvent to deregister the singleton"""
        class_name = self.__class__.__name__
        if DialogSingletonMixin.debug:
            print(f'DEBUG: SingletonDialog remove {class_name}')
        del DialogSingletonMixin._dialogs_map[class_name]
        event.accept()

    def make_visible(self):
        """
        If the dialog exists(), call this to make it visible by raising it.
        Internal, used by the class method show_existing_dialog()
        """
        self.show()
        self.raise_()
        self.activateWindow()

    @classmethod
    def show_existing_dialog(cls: Type):
        """If the dialog exists(), call this to make it visible by raising it."""
        class_name = cls.__name__
        if DialogSingletonMixin.debug:
            print(f'DEBUG: SingletonDialog show existing {class_name}')
        instance = DialogSingletonMixin._dialogs_map[class_name]
        instance.make_visible()

    @classmethod
    def exists(cls: Type) -> bool:
        """Returns true if the dialog has already been created."""
        class_name = cls.__name__
        if DialogSingletonMixin.debug:
            print(f'DEBUG: SingletonDialog exists {class_name} {class_name in DialogSingletonMixin._dialogs_map}')
        return class_name in DialogSingletonMixin._dialogs_map


class AboutDialog(QMessageBox, DialogSingletonMixin):

    @staticmethod
    def invoke():
        if AboutDialog.exists():
            AboutDialog.show_existing_dialog()
        else:
            AboutDialog()

    def __init__(self):
        super().__init__()
        self.setWindowTitle(translate('About'))
        self.setTextFormat(Qt.AutoText)
        self.setText(translate('About jouno'))
        self.setInformativeText(translate(ABOUT_TEXT))
        self.setIcon(QMessageBox.Information)
        self.exec()


class HelpDialog(QDialog, DialogSingletonMixin):

    @staticmethod
    def invoke():
        if HelpDialog.exists():
            HelpDialog.show_existing_dialog()
        else:
            HelpDialog()

    def __init__(self):
        super().__init__()
        self.setWindowTitle(translate('Help'))
        layout = QVBoxLayout()
        markdown_view = QTextEdit()
        markdown_view.setReadOnly(True)
        markdown_view.setMarkdown(__doc__)
        layout.addWidget(markdown_view)
        self.setLayout(layout)
        # TODO maybe compute a minimum from the actual screen size
        self.setMinimumWidth(1600)
        self.setMinimumHeight(1024)
        # .show() is non-modal, .exec() is modal
        self.make_visible()


class ContextMenu(QMenu):

    def __init__(self,
                 about_action=None, help_action=None, enable_action=None,
                 quit_action=None) -> None:
        super().__init__()
        self.main_window = None

        toggle_action = self.addAction(
            self.style().standardIcon(QStyle.SP_ComputerIcon),
            translate('Pause'),
            enable_action)
        self.addAction(self.style().standardIcon(QStyle.SP_MessageBoxInformation),
                       translate('About'),
                       about_action)
        self.addAction(self.style().standardIcon(QStyle.SP_TitleBarContextHelpButton),
                       translate('Help'),
                       help_action)
        self.addSeparator()
        self.addAction(self.style().standardIcon(QStyle.SP_DialogCloseButton),
                       translate('Quit'),
                       quit_action)

        def triggered(action: QAction):
            print('triggered', action.text(), toggle_action.text())
            if action == toggle_action:
                action.setText(translate('Continue') if action.text() == translate("Pause") else translate("Pause"))

        self.triggered.connect(triggered)

    def set_vdu_controls_main_window(self, main_window) -> None:
        self.main_window = main_window


def exception_handler(e_type, e_value, e_traceback):
    """Overarching error handler in case something unexpected happens."""
    print("ERROR:\n", ''.join(traceback.format_exception(e_type, e_value, e_traceback)))
    alert = QMessageBox()
    alert.setText(translate('Error: {}').format(''.join(traceback.format_exception_only(e_type, e_value))))
    alert.setInformativeText(translate('Unexpected error'))
    alert.setDetailedText(
        translate('Details: {}').format(''.join(traceback.format_exception(e_type, e_value, e_traceback))))
    alert.setIcon(QMessageBox.Critical)
    alert.exec()
    stop_watch_journal()
    QApplication.quit()


def user_interface():
    sys.excepthook = exception_handler

    app = QApplication(sys.argv)

    window_icon = create_icon_from_svg_string(WINDOW_ICON_SVG)
    watch_on_icon = create_icon_from_svg_string(FILTER_SVG)
    watch_off_icon = create_icon_from_svg_string(FILTER_OFF_SVG)

    def toggle_watcher() -> None:
        global watcher_process
        if watcher_process.is_alive():
            stop_watch_journal()
            tray.setIcon(watch_off_icon)
        else:
            start_watch_journal()
            tray.setIcon(watch_on_icon)

    def quit_action():
        stop_watch_journal()
        app.quit()

    app_context_menu = ContextMenu(
        about_action=AboutDialog.invoke,
        help_action=HelpDialog.invoke,
        enable_action=toggle_watcher,
        quit_action=quit_action)

    tray = QSystemTrayIcon()
    tray.setIcon(watch_on_icon)
    tray.setContextMenu(app_context_menu)

    app.setWindowIcon(window_icon)
    app.setApplicationDisplayName(translate('Journal Notification Forwarder'))

    def open_context_menu(position: QPoint) -> None:
        print("context menu")
        app_context_menu.exec(main_window.mapToGlobal(position))

    main_window = ConfigEditorWidget()
    main_window.customContextMenuRequested.connect(open_context_menu)

    def show_window():
        if main_window.isVisible():
            main_window.hide()
        else:
            # Use the mouse pos as a guess to where the system tray is.  The Linux Qt x,y geometry returned by
            # the tray icon is 0,0, so we can't use that.
            p = QCursor.pos()
            wg = main_window.geometry()
            # Also try to cope with the tray not being at the bottom right of the screen.
            x = p.x() - wg.width() if p.x() > wg.width() else p.x()
            y = p.y() - wg.height() if p.y() > wg.height() else p.y()
            main_window.setGeometry(x, y, wg.width(), wg.height())
            main_window.show()
            # Attempt to force it to the top with raise and activate
            main_window.raise_()
            main_window.activateWindow()

    tray.activated.connect(show_window)
    tray.setVisible(True)
    rc = app.exec_()
    if rc == 999:  # EXIT_CODE_FOR_RESTART:
        QProcess.startDetached(app.arguments()[0], app.arguments()[1:])


def watch_journal():
    journal_watcher = JournalWatcher()
    journal_watcher.watch_journal()


watcher_process: mp.Process = None


def start_watch_journal():
    global watcher_process
    if watcher_process is not None and watcher_process.is_alive():
        watcher_process.terminate()
    watcher_process = mp.Process(target=watch_journal, args=())
    watcher_process.start()
    print(f"started watcher PID={watcher_process.pid}")


def stop_watch_journal():
    global watcher_process
    if watcher_process is not None and watcher_process.is_alive():
        watcher_process.terminate()
        watcher_process.join()
        print(f"terminated watcher PID={watcher_process.pid} exit code={watcher_process.exitcode}")


def main():
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    start_watch_journal()
    user_interface()


if __name__ == '__main__':
    main()
