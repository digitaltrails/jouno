#!/usr/bin/python3
"""
jouno: Journal notifications forwarder
======================================

A Systemd-Journal to Freedesktop-Notifications forwarder with burst-handling and filtering.

Usage:
======

        jouno [-h]
                     [--about] [--detailed-help]
                     [--install] [--uninstall]

Optional arguments:
-------------------

      -h, --help            show this help message and exit
      --detailed-help       full help in markdown format
      --about               about jouno
      --install             installs the jouno in the current user's path and desktop application menu.
      --uninstall           uninstalls the jouno application menu file and script for the current user.

Description
===========

This software is currently pre-release, It is feature complete and quite usable but may lack some polish.

``jouno,`` is system-tray application for monitoring the ``systemd-journal.`` It raises selected
entries as desktop-notifications.

The application monitors the ``systemd-journal`` for new entries, filters them, and forwards them as
standard ``freedesktop dbus notifications``.  Most linux desktops present these notifications
as individual popup messages.

Bursts of messages are handled by bundling them in to a single summarising notification.

``jouno`` is a tool designed to improve awareness of background activity by monitoring
the journal and raising interesting journal-entries as desktop notifications.  Possibilities for
it use include:

 * Monitoring specific jobs, such as the progress of the daily backups.
 * Watching for specific events, such as background core dumps.
 * Investigating desktop actions that raise journal log entries.
 * Discovering unnecessary daemon activity and unnecessary services.
 * Notifying access attempts, such as su, ssh, samba, or pam events.
 * Prevention of undesirable desktop activity, such as shutting down during the backups.
 * Detecting hardware events.
 * Raising general awareness of what is going on in the background.

I have previously released a gist [notify-desktop](https://gist.github.com/digitaltrails/26aad3282d8739db1de8bc2e59c812eb)
that allows root batch-jobs, such as my daily backups, to raise notifications for the current desktop
user, but ``notify-desktop`` only covers my own code.  ``jouno`` allows me to watch for and monitor any
jobs on the system and potentially removes the need for my jobs to use my ``notify-desktop`` script.

Configuration
=============

Clicking on the ``jouno`` system-tray icon brings up an ``options and filters`` panel which includes three
tabs:

  1. Options: settings that adjust how to display messages and how to collate of bursts af messages

  2. Match Filters: filters that restrict notifications to only journal entries they match.

  3. Ignore Filters: filters that restrict notifications by ignoring journal entries they match.

Match filtering is most useful when only minimal journal entries are of interest and the other entries aren't
of interest.  For example, a match-filter might be set for core-dump journal entries only.

Ignore filtering is most useful when almost any journal entries might be of interest and only a few journal
items need to be ignored.  For example, if any unexpected messages might be of interest, ignore-filters could
be set up for any that are routine.

It's common to require a few ignore-filters to discard any messages generated by the desktop notification system
in response to notices being posted.

Match and Ignore Patterns
-------------------------

 * Journal entries are filtered by list of rules.  Each rule defines a ``Rule ID`` and a ``pattern.``

 * Each rule is identified by a ``Rule ID`` which is text identifier compliant with commonly accepted
   variable naming conventions, for example:
   ```
   my_id
   my-id
   myId21
   ```

 * Rule ID's that end with a ``_regexp`` suffix define a regular-expression pattern, while those that
   do not end in ``_regexp`` define a literal-text pattern. For example:
   ```
   my-id_rexp
   ```
   versus
   ```
   my-id
   ```

 * Patterns may match any fragment of text seen in actual journal entries.

 * Patterns may also match specific journal entry fields, for example:
   ```
   'SYSLOG_IDENTIFIER=su'
   '_GID=500',
   '_HOSTNAME=kosmos1'
   'PRIORITY=7',
   '_CMDLINE=/usr/bin/kded5'
   '_PID=2143',
   ```
   When attempting to match specific fields surround the pattern with single-quotes
   to ensure that complete values are matched, for example: ``'_GID=500'``  will
   only match the intended field and value, it won't match ``PARENT_GID=5000``.

   The list of possible field names can be found at:

      [https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html)

Config files
------------

The config files are in INI-format divided into a number of sections as outlined below::

        # The options section controls notice timeouts, burst treatment
        [options]
        # Polling interval, how often to wait for journal entries between checking for config changes
        poll_seconds = 2
        # Wait at lease burst_seconds before declaring a burst of messages to have finished
        burst_seconds = 5
        # Only show the the first burst_truncate_messages of a burst
        burst_truncate_messages = 3
        # Set journo messages to timeout/auto-dismiss after notification-seconds
        notification_seconds = 30
        # For debugging the application
        debug = yes

        [match]
        # Each filter rule has an id and the message text to match
        my_rule_id = forward journal entry if this string matches
        # Each filter rule can be disabled by a corresponding my_rule_id_enabled = no option
        my_rule_id_enabled = no
        # A filter id that ends in _regexp is treated as a python regular-expression
        my_other_rule_id_regexp = forward journal [Ee]ntry if this python-regexp matches

        [ignore]
        my_ignore_rule_id = ignore journal entry if this string matches
        my_ignore_other_rule_id_regexp = ignore [Jj]ournal entry if this python-regexp matches

The config files are optional, but some filtering of the journal is likely to be necessary.
``jouno`` copes with cascades and won't cause infinite cascades, but filtering may be necessary
to eliminate excessive bursts caused by the desktop when it processes the notifications generated
by jouno.


Responsiveness
--------------

I've logged a bug against the KDE plasma notifications. Generating multiple messages with expiry timeouts
cause plasma-notifications and the kwin-x11 to cosume a large amount of CPU and become jerky when dragging
windows.  This doesn't seem to happen if notices do not expire (``notification_seconds = 0``).  This
isn't a bug confined to jouno generated notifications, it can be reproduced by normal shell commands,
for example:

  for i in 1 2 3 4 5 6 7 8 9 10; do notify-send --expire-time 30 test $i;done

The problem can be reduced by using sufficient match/ignore filters or by turning off notification
expiry by setting ``notification_seconds = 0``

Examples
========

    jouno
        All default controls.



Prerequisites
=============

All the following runtime dependencies are likely to be available pre-packaged on any modern Linux distribution
(``jouno`` was originally developed on OpenSUSE Tumbleweed).

* python 3.8: ``journo`` is written in python and may depend on some features present only in 3.8 onward.
* python 3.8 QtPy: the python GUI library used by ``jouno``.
* python 3.8 systemd: python module for native access to the systemd facilities.
* python 3.8 dbus: python module for dbus used for issuing notifications

Dependency installation on ``OpenSUSE``::

        zypper install python38-QtPy python38-systemd python38-dbus


jouno Copyright (C) 2021 Michael Hamilton
===========================================

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, version 3.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along
with this program. If not, see <https://www.gnu.org/licenses/>.

**Contact:**  m i c h a e l   @   a c t r i x   .   g e n   .   n z

----------

"""

# TODO Add option for how many journal rows to show - if zero hide panel.
# TODO Add option for non-tray use.
# TODO Consider creating a separate full log browser making use of the journal API for search and random access.
# DONE Search 'recent' on toolbar
# TODO Display more fields in 'recent' - priority as icon perhaps.
# DONE https://specifications.freedesktop.org/icon-naming-spec/latest/
# TODO Position the GUI to the left so as not to be covered by alerts.
# TODO Smaller Apply/Revert button widths.
# TODO Fix tray hover title

import argparse
import configparser
import os
import pickle
import re
import select
import signal
import stat
import sys
import textwrap
import time
import traceback
from enum import Enum
from pathlib import Path
from typing import Mapping, Any, List, Type, Callable

import dbus
from PyQt5.QtCore import QCoreApplication, QProcess, Qt, pyqtSignal, QThread, QModelIndex, QItemSelectionModel, QSize
from PyQt5.QtGui import QPixmap, QIcon, QImage, QPainter, QCursor, QStandardItemModel, QStandardItem, QIntValidator, \
    QFontDatabase, QGuiApplication
from PyQt5.QtSvg import QSvgRenderer
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QMessageBox, QLineEdit, QLabel, \
    QPushButton, QSystemTrayIcon, QMenu, QTextEdit, QDialog, QTabWidget, \
    QCheckBox, QGridLayout, QTableView, \
    QAbstractItemView, QHeaderView, QSplitter, QMainWindow, QSizePolicy, QStyledItemDelegate, QToolBar
from systemd import journal

JOUNO_VERSION = '0.9.0'

ICON_HELP_ABOUT = QIcon.fromTheme("help-about")
ICON_HELP_CONTENTS = QIcon.fromTheme("help-contents")
ICON_APPLICATION_EXIT = QIcon.fromTheme("application-exit")
ICON_CONTEXT_MENU_LISTENING_ENABLE = QIcon.fromTheme("view-refresh")
ICON_CONTEXT_MENU_LISTENING_DISABLE = QIcon.fromTheme("process-stop")
ICON_TRAY_LISTENING_DISABLED = ICON_CONTEXT_MENU_LISTENING_DISABLE
ICON_COPY_TO_CLIPBOARD = QIcon.fromTheme("edit-copy")
ICON_SEARCH_JOURNAL = QIcon.fromTheme("system-search")

def create_image_from_svg_string(svg_str: bytes) -> QImage:
    """There is no QIcon option for loading QImage from a string, only from a SVG file, so roll our own."""
    renderer = QSvgRenderer(svg_str)
    image = QImage(64, 64, QImage.Format_ARGB32)
    image.fill(0x0)
    painter = QPainter(image)
    renderer.render(painter)
    painter.end()
    return image


def create_pixmap_from_svg_string(svg_str: bytes) -> QPixmap:
    """There is no QIcon option for loading SVG from a string, only from a SVG file, so roll our own."""
    image = create_image_from_svg_string(svg_str)
    return QPixmap.fromImage(image)


def create_icon_from_svg_string(default_svg: bytes = None,
                                on_svg: bytes = None, off_svg: bytes = None,
                                disabled_svg: bytes = None) -> QIcon:
    """There is no QIcon option for loading SVG from a string, only from a SVG file, so roll our own."""
    if default_svg is not None:
        icon = QIcon(create_pixmap_from_svg_string(default_svg))
    else:
        icon = QIcon()
    if on_svg is not None:
        icon.addPixmap(create_pixmap_from_svg_string(on_svg), state=QIcon.On)
    if off_svg is not None:
        icon.addPixmap(create_pixmap_from_svg_string(off_svg), state=QIcon.Off)
    if disabled_svg:
        icon = QIcon(create_pixmap_from_svg_string(on_svg), mode=QIcon.Disabled)
    return icon


JOUNO_ICON_SVG = b"""
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
 <path fill="#232629" style="fill:currentColor;fill-opacity:1;stroke:none" 
      d="M 4 2 L 4 3 L 13 3 L 13 13 L 4 13 L 4 14 L 13 14 L 14 14 L 14 3 L 14 2 L 7 2 z"
      class="ColorScheme-Text"
     />
 <path fill="#3491e1" style="fill-opacity:1;stroke:none" 
      d="M 8 6 L 8 8 L 12 8 L 12 7 L 8 7 z M 8 8 L 8 10 L 12 10 L 12 9 L 8 9 z M 8 11 L 8 12 L 12 12 L 12 11 L 10 11 z "

     />

</svg>
"""

JOUNO_ICON_LIGHT_SVG = JOUNO_ICON_SVG.replace(b'#232629', b'#bbbbbb')

TOOLBAR_RUN_DISABLED_SVG = b"""
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 22">
    <style type="text/css" id="current-color-scheme">
        .ColorScheme-Text {
            color:#232629;
        }
    </style>
    <path d="m3 3v16l16-8z" class="ColorScheme-Text" fill="currentColor"/>
</svg>
"""

TOOLBAR_RUN_ENABLED_SVG = TOOLBAR_RUN_DISABLED_SVG.replace(b"#232629;", b"#3daee9;")

TOOLBAR_STOP_SVG = b"""
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 22">
    <style type="text/css" id="current-color-scheme">
        .ColorScheme-Text {
            color:#da4453;
        }
    </style>
    <path d="m3 3h16v16h-16z" class="ColorScheme-Text" fill="currentColor"/>
</svg>
"""

TOOLBAR_NOTIFIER_ENABLED_SVG = b"""
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 22">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#379fd3;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none"
       d="M 3 4 L 3 16 L 6 20 L 6 17 L 6 16 L 19 16 L 19 4 L 3 4 z M 4 5 L 18 5 L 18 15 L 4 15 L 4 5 z M 16 6 L 9.5 12.25 L 7 10 L 6 11 L 9.5 14 L 17 7 L 16 6 z "
     class="ColorScheme-Text"
     />
</svg>
"""

TOOLBAR_NOTIFIER_DISABLED_SVG = b"""
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 22">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#da4453;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none"
       d="M 3 4 L 3 16 L 6 20 L 6 17 L 6 16 L 19 16 L 19 4 L 3 4 z M 4 5 L 18 5 L 18 15 L 4 15 L 4 5 z M 8 6 L 7 7 L 10 10 L 7 13 L 8 14 L 11 11 L 14 14 L 15 13 L 12 10 L 15 7 L 14 6 L 11 9 L 8 6 z "
     class="ColorScheme-Text"
     />
</svg>

"""

TOOLBAR_ADD_FILTER_SVG = b"""
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 22">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path 
     style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 5 3 L 4 4 L 4 5 L 4 5.3046875 L 9 12.367188 L 9 16 L 9 16.039062 L 12.990234 19 L 13 19 L 13 12.367188 L 18 5.3046875 L 18 4 L 17 3 L 5 3 z M 5 4 L 17 4 L 17 4.9882812 L 12.035156 12 L 12 12 L 12 12.048828 L 12 13 L 12 17.019531 L 10 15.535156 L 10 13 L 10 12.048828 L 10 12 L 9.9648438 12 L 5 4.9882812 L 5 4 z M 6 5 L 8 8 L 8 6 L 10 5 L 6 5 z M 16 14 L 16 16 L 14 16 L 14 17 L 16 17 L 16 19 L 17 19 L 17 17 L 19 17 L 19 16 L 17 16 L 17 14 L 16 14 z "
     class="ColorScheme-Text"
     />
</svg>
"""

TOOLBAR_DEL_FILTER_SVG = b"""
<svg id="svg8" version="1.1" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg">
    <defs id="defs3051">
        <style id="current-color-scheme" type="text/css">.ColorScheme-Text {
        color:#232629;
      }</style>
    </defs>
    <path id="path4" class="ColorScheme-Text" d="m5 3-1 1v1.3046875l5 7.0625005v3.671872l3 2.226563v-1.246092l-2-1.484375v-3.535156h-0.035156l-4.964844-7.0117188v-0.9882812h12v0.9882812l-4.964844 7.0117188h1.22461l4.740234-6.6953125v-1.3046875l-1-1zm1 2 2 3v-2l2-1z" fill="currentColor"/>
    <path id="path6" d="M 13.990234,13 13,13.990234 15.009766,16 13,18.009766 13.990234,19 16,16.990234 18.009766,19 19,18.009766 16.990234,16 19,13.990234 18.009766,13 16,15.009766 Z" fill="#da4453"/>
</svg>
"""

TABLE_HEADER_STYLE = "font-weight: bold;font-size: 9pt;"

ABOUT_TEXT = f"""

<b>jouno version {JOUNO_VERSION}</b>
<p>
A journal-entry to desktop-notification forwarder. 
<p>
<i>Right-mouse &rarr; context-menu &rarr; help</i> for help.
<p>
Visit <a href="https://github.com/digitaltrails/jouno">https://github.com/digitaltrails/jouno</a> for 
more details.
<p><p>

<b>jouno Copyright (C) 2021 Michael Hamilton</b>
<p>
This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, version 3.
<p>
This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
more details.
<p>
You should have received a copy of the GNU General Public License along
with this program. If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.

"""

DEFAULT_CONFIG = '''
[options]
poll_seconds = 2
burst_seconds = 5
burst_truncate_messages = 3
notification_seconds = 60
debug_enabled = yes

[ignore] 
kwin_bad_damage = XCB error: 152 (BadDamage)
kwin_bad_window = kwin_core: XCB error: 3 (BadWindow)
self_caused = NotificationPopup.
qt_kde_binding_loop = Binding loop detected for property

[match]

'''


# ######################## MONITOR SUB PROCESS CODE ###############################################################


class Priority(Enum):
    EMERGENCY = 0
    ALERT = 1
    CRITICAL = 2
    ERR = 3
    WARNING = 4
    NOTICE = 5
    INFO = 6
    DEBUG = 7


NOTIFICATION_ICONS = {
    Priority.EMERGENCY: 'dialog-error',
    Priority.ALERT: 'dialog-error',
    Priority.CRITICAL: 'dialog-error',
    Priority.ERR: 'dialog-error',
    Priority.WARNING: 'dialog-warning',
    Priority.NOTICE: 'dialog-information',
    Priority.INFO: 'dialog-information',
    Priority.DEBUG: 'dialog-information',
}

debug_enabled = True


def debug(*arg):
    if debug_enabled:
        print('DEBUG:', *arg)


def info(*arg):
    print('INFO:', *arg)


xml_escape_table = str.maketrans({
    "<": "&lt;",
    ">": "&gt;",
    "&": "&amp;",
    "'": "&apos;",
    '"': "&quot;",
})


def xmlesc(txt: str):
    return txt.translate(xml_escape_table)


class NotifyFreeDesktop:

    def __init__(self):
        self.notify_interface = dbus.Interface(
            object=dbus.SessionBus().get_object("org.freedesktop.Notifications", "/org/freedesktop/Notifications"),
            dbus_interface="org.freedesktop.Notifications")

    def notify_desktop(self, app_name: str, summary: str, message: str, priority: Priority, timeout: int):
        # https://specifications.freedesktop.org/notification-spec/notification-spec-latest.html
        replace_id = 0
        notification_icon = NOTIFICATION_ICONS[priority] + ".png"
        action_requests = []
        # extra_hints = {"urgency": 1, "sound-name": "dialog-warning", }
        extra_hints = {}
        self.notify_interface.Notify(app_name, replace_id, notification_icon, summary, message, action_requests,
                                     extra_hints,
                                     timeout)


def get_config_path() -> Path:
    config_dir_path = Path.home().joinpath('.config').joinpath('jouno')
    if not config_dir_path.parent.is_dir():
        os.makedirs(config_dir_path)
    path = config_dir_path.joinpath('jouno.conf')
    return path


class Config(configparser.ConfigParser):

    def __init__(self):
        super().__init__()
        self.path = get_config_path()
        self.modified_time = 0.0
        self.read_string(DEFAULT_CONFIG)

    def save(self):
        with open(self.path, 'w') as config_file:
            self.write(config_file)

    def refresh(self) -> bool:
        if self.path.is_file():
            modified_time = self.path.lstat().st_mtime
            if self.modified_time == modified_time:
                return False
            self.modified_time = modified_time
            info(f"Reading {self.path}")
            config_text = self.path.read_text()
            for section in ['options', 'match', 'ignore']:
                self.remove_section(section)
            self.read_string(config_text)
            for section in ['options', 'match', 'ignore']:
                if section not in self:
                    self[section] = {}
            return True
        if self.modified_time > 0.0:
            info(f"Config file has been deleted: {self.path}")
            self.modified_time = 0.0
        return False


class JournalWatcher:

    def __init__(self, supervisor=None):
        self.config: Config = None
        self.burst_truncate: int = 3
        self.polling_millis: int = 2_000
        self.notification_timeout_millis: int = 60_000
        self.burst_max_millis = 10_000
        self.ignore_regexp: Mapping[str, re] = {}
        self.match_regexp: Mapping[str, re] = {}
        self.update_config()
        self._stop = False
        self.supervisor = supervisor
        self.notifications_enabled = True

    def is_notifying(self) -> bool:
        return self.notifications_enabled

    def enable_notifications(self, enable: bool):
        self.notifications_enabled = enable

    def update_config(self):
        if self.config is None:
            self.config = Config()
        if not self.config.refresh():
            return
        if 'poll_seconds' in self.config['options']:
            self.polling_millis = 1_000 * self.config.getint('options', 'poll_seconds')
        if 'burst_truncate_messages' in self.config['options']:
            self.burst_truncate = self.config.getint('options', 'burst_truncate_messages')
        if 'burst_seconds' in self.config['options']:
            self.burst_max_millis = 1_000 * self.config.getint('options', 'burst_seconds')
        if 'notification_seconds' in self.config['options']:
            self.notification_timeout_millis = 1_000 * self.config.getint('options', 'notification_seconds')
        if 'debug' in self.config['options']:
            global debug_enabled
            debug_enabled = self.config.getboolean('options', 'debug')
        self.ignore_regexp: Mapping[str, re] = {}
        self.match_regexp: Mapping[str, re] = {}
        self.compile_patterns(self.config['match'], self.match_regexp)
        self.compile_patterns(self.config['ignore'], self.ignore_regexp)

    def compile_patterns(self, rules_map: Mapping[str, str], patterns_map: Mapping[str, re.Pattern]):
        for rule_id, rule_text in rules_map.items():
            if rule_id.endswith('_enabled'):
                pass
            else:
                rule_enabled_key = rule_id + "_enabled"
                if rule_enabled_key not in rules_map or rules_map[rule_enabled_key].lower() == 'yes':
                    debug(f"including {rule_id}")
                    if rule_id.endswith('_regexp'):
                        patterns_map[rule_id] = re.compile(rule_text)
                    else:
                        patterns_map[rule_id] = re.compile(re.escape(rule_text))

    def determine_app_name(self, journal_entries: List[Mapping[str, Any]]):
        app_name_info = ''
        sep = '\u25b3'
        for journal_entry in journal_entries:
            for key, prefix in {'_CMDLINE': '', '_EXE': '', '_COMM': '', 'SYSLOG_IDENTIFIER': '',
                                '_KERNEL_SUBSYSTEM': 'kernel ',
                                }.items():
                print(key, journal_entry[key] if key in journal_entry else False)
                if key in journal_entry:
                    value = str(journal_entry[key])
                    if app_name_info.find(value) < 0:
                        app_name_info += sep + prefix + value
                        sep = '; '
        if app_name_info == '':
            app_name_info = sep + 'unknown'
        return app_name_info

    def determine_summary(self, journal_entries: List[Mapping[str, Any]]):
        journal_entry = journal_entries[0]
        realtime = journal_entry['__REALTIME_TIMESTAMP']
        transport = f" {journal_entry['_TRANSPORT']}" if '_TRANSPORT' in journal_entry else ''
        number_of_entries = len(journal_entries)
        if number_of_entries > 1:
            summary = f"\u25F4{realtime:%H:%M:%S}:{transport} Burst of {number_of_entries} messages"
        else:
            text = ''
            sep = ''
            for key, prefix in {'SYSLOG_IDENTIFIER': '', '_PID': 'PID ', '_KERNEL_SUBSYSTEM': 'kernel ', }.items():
                if key in journal_entry:
                    value = str(journal_entry[key])
                    if text.find(value) < 0:
                        text += sep + prefix + value
                        sep = ' '
            summary = f"\u25F4{realtime:%H:%M:%S}: {text} (\u21e8{transport})"
        debug(f"realtime='{realtime}' summary='{summary}'")
        return summary

    def determine_message(self, journal_entries: List[Mapping[str, Any]]) -> str:
        message = ''
        sep = ''
        previous_message = ''
        duplicates = 0
        reported = 0
        for journal_entry in journal_entries:
            new_message = journal_entry['MESSAGE']
            if new_message == previous_message:
                duplicates += 1
            else:
                message += f"{sep}\u25B7{new_message}"
                previous_message = new_message
                reported += 1
                if reported == self.burst_truncate and reported < len(journal_entries):
                    message += f"\n[Only showing first {self.burst_truncate} messages]"
                    break
            sep = '\n'
        if duplicates > 0:
            message += f'\n[{duplicates + 1} duplicate messages]'
        debug(f'message={message}')
        return message

    def determine_priority(self, journal_entries: List[Mapping[str, Any]]) -> Priority:
        current_level = Priority.NOTICE
        for journal_entry in journal_entries:
            if 'PRIORITY' in journal_entry:
                priority = journal_entry['PRIORITY']
                if priority < current_level.value and (Priority.EMERGENCY.value <= priority <= Priority.DEBUG.value):
                    current_level = Priority(priority)
        return current_level

    def is_notable(self, journal_entry: Mapping[str, Any]):
        # Is a list comprehension slower than a for-loop for string construction?
        # Use an easy a format that is easy to pattern match
        fields_str = ', '.join((f"'{key}={str(value)}'" for key, value in journal_entry.items()))
        debug(fields_str)
        for rule_id, match_re in self.match_regexp.items():
            if match_re.search(fields_str) is not None:
                debug(f"rule=match.{rule_id}: {journal_entry['MESSAGE']}")
                return True
        for rule_id, ignore_re in self.ignore_regexp.items():
            if ignore_re.search(fields_str) is not None:
                debug(f"rule=ignore.{rule_id}: {journal_entry['MESSAGE']}")
                return False
        # otherwise no patterns matched:
        # 1) if there are any 'match' patterns at all, we need to return False.
        # 2) if there are no 'match' patterns at all, we need to return True.
        return len(self.match_regexp) == 0

    def is_stop_requested(self) -> bool:
        return self.supervisor.isInterruptionRequested()

    def watch_journal(self, entry_callback=None):
        self._stop = False
        notify = NotifyFreeDesktop()

        journal_reader = journal.Reader()
        journal_reader.seek_tail()
        journal_reader.get_previous()

        journal_reader_poll = select.poll()
        journal_reader_poll.register(journal_reader, journal_reader.get_events())
        journal_reader.add_match()
        while True:
            if self.is_stop_requested():
                return
            self.update_config()
            burst_count = 0
            notable = []
            limit_time_ns = self.burst_max_millis * 1_000_000 + time.time_ns()
            while journal_reader_poll.poll(self.polling_millis) and time.time_ns() < limit_time_ns:
                if self.is_stop_requested():
                    return
                if journal_reader.process() == journal.APPEND:
                    for journal_entry in journal_reader:
                        if self.is_stop_requested():
                            return
                        burst_count += 1
                        if self.is_notable(journal_entry):
                            debug(f"Notable: burst_count={len(notable)}: {journal_entry['MESSAGE']}")
                            notable.append(journal_entry)
                            self.supervisor.new_journal_entry(journal_entry)
            if self.notifications_enabled and len(notable):
                notify.notify_desktop(app_name=self.determine_app_name(notable),
                                      summary=self.determine_summary(notable),
                                      message=self.determine_message(notable),
                                      priority=self.determine_priority(notable),
                                      timeout=self.notification_timeout_millis)


def tr(source_text: str):
    """For future internationalization - recommended way to do this at this time."""
    return QCoreApplication.translate('jouno', source_text)


# ######################## USER INTERFACE CODE ######################################################################


class OptionsTab(QWidget):

    def __init__(self, config_section: Mapping[str, str], parent: QWidget = None):
        super().__init__(parent=parent)
        self.option_map: Mapping[str, QWidget] = {}
        layout = QGridLayout(self)
        row_number = 0
        for option_id, value in config_section.items():
            label_widget = QLabel(tr(option_id))
            if option_id.endswith("_enabled"):
                input_widget = QCheckBox()
                input_widget.setChecked(value == 'yes')
            else:
                input_widget = QLineEdit()
                input_widget.setValidator(QIntValidator(0, 60))
                input_widget.setMaximumWidth(100)
                input_widget.setText(value)
            layout.addWidget(label_widget, row_number, 0)
            layout.addWidget(input_widget, row_number, 1, 1, 2, alignment=Qt.AlignLeft)
            self.option_map[option_id] = input_widget
            row_number += 1
        # Add a spacer to force those above to scrunch up.
        layout.addWidget(QWidget(), row_number, 1, 2, 2, alignment=Qt.AlignLeft)
        self.setLayout(layout)

    def copy_from_config(self, config_section: Mapping[str, str]):
        for option_id, widget in self.option_map.items():
            if option_id in config_section:
                if option_id.endswith("_enabled"):
                    widget.setChecked(config_section[option_id].lower() == "yes")
                else:
                    widget.setText(config_section[option_id])

    def copy_to_config(self, config_section: Mapping[str, str]):
        for option_id, widget in self.option_map.items():
            if option_id.endswith("_enabled"):
                config_section[option_id] = "yes" if widget.isChecked() else "no"
            else:
                if widget.text().strip() != "":
                    config_section[option_id] = widget.text()


class FilterPanel(QWidget):

    def __init__(self, config_section: Mapping[str, str], tooltip: str = 'tip', parent: QWidget = None):
        super().__init__(parent=parent)
        print("table", str(config_section.keys()))

        self.table_view = FilterTableView(config_section, tooltip)

        # TODO add a test rules button that pops up a testing dialog with an input field.
        layout = QVBoxLayout(self)
        layout.addWidget(self.table_view)
        self.setLayout(layout)

    def is_valid(self):
        return self.table_view.is_valid()

    def copy_from_config(self, config_section: Mapping[str, str]):
        self.table_view.copy_from_config(config_section)

    def copy_to_config(self, config_section: Mapping[str, str]):
        self.table_view.copy_to_config(config_section)

    def clear_selection(self):
        self.table_view.clearSelection()

    def add_rule(self, rule_id: str = '', pattern: str = ''):
        self.table_view.add_new_rule(rule_id, pattern)

    def delete_rules(self):
        self.table_view.delete_selected_rules()


class FilterTableModel(QStandardItemModel):

    def __init__(self, number_of_rows: int):
        super().__init__(number_of_rows, 2)
        # use spaces to force a wider column - seems to be no other EASY way to do this.
        self.setHorizontalHeaderLabels(
            [tr("Rule-ID (enabled/disabled)"), tr("Pattern")])


class FilterValidationException(Exception):
    pass


class FilterTableView(QTableView):

    def __init__(self, config_section: Mapping[str, str], tooltip=""):
        super().__init__()
        self.enable_tooltip = \
            tr("Enable: rules can be selective enabled/disabled.")
        self.rule_id_tooltip_1 = \
            tr("Rule ID: a letter followed by letters, digits, underscores and hyphens")
        self.rule_id_tooltip_2 = \
            tr("A rule ID with a _regexp suffix denotes its pattern to be a regular expression.")
        self.pattern_tooltip = \
            tr("Pattern: Text or regexp to partially match in the journal entry's message field.")
        tooltip += "\n\n" + tr("Columns:") + "\n" + \
                   tr(f"    {self.enable_tooltip}\n") + \
                   tr(f"    {self.rule_id_tooltip_1}\n") + \
                   tr(f"          {self.rule_id_tooltip_2}\n") + \
                   tr(f"    {self.pattern_tooltip}\n")
        self.setToolTip(tooltip)
        self.setModel(FilterTableModel(len(config_section)))
        self.copy_from_config(config_section)
        self.setEditTriggers(QAbstractItemView.AllEditTriggers)
        self.verticalHeader().setSectionsMovable(True)
        self.verticalHeader().setDragEnabled(True)
        self.verticalHeader().setDragDropMode(QAbstractItemView.InternalMove)
        self.setDragDropOverwriteMode(True)
        self.resizeColumnsToContents()
        self.setSelectionMode(QAbstractItemView.SingleSelection)
        self.setSelectionBehavior(QAbstractItemView.SelectRows)
        # self.setItemDelegateForColumn(1, ColumnItemDelegate())
        self.horizontalHeader().setSectionResizeMode(1, QHeaderView.Stretch)
        self.horizontalHeader().setDefaultAlignment(Qt.AlignLeft)
        self.horizontalHeader().setStyleSheet(TABLE_HEADER_STYLE)
        self.setShowGrid(False)

    def item_view_order(self) -> List[int]:
        """
        Walk the table model's rows in model-order of 1..n, find the current y-location or each row,
        sort the y-locations to determine the current view ordering of the model's rows (which may
        no longer be 1..n due to drag and drop).  Return a list of the current view ordering, for
        example [4, 0, 1, 2, 3].
        """
        # If there is no access to the rowCount, rowViewportPosition() can be called
        # until it returns -1 (note it can return other valid negative values, so just test
        # for -1.
        row_y_positions = []
        debug(f"row count={self.model().rowCount()}")
        for row_num in range(self.model().rowCount()):
            y = self.rowViewportPosition(row_num)
            row_y_positions.append((y, row_num))
        row_y_positions.sort()
        return [row_num for _, row_num in row_y_positions]

    def create_rule_id_item(self, rule_id: str):
        enable_item = QStandardItem(rule_id)
        enable_item.setCheckable(True)
        enable_item.setCheckState(Qt.Checked)
        enable_item.setEditable(True)
        enable_item.setToolTip(tr(self.rule_id_tooltip_1 + "\n" + self.rule_id_tooltip_2))
        return enable_item

    def is_valid(self) -> bool:
        model = self.model()
        seen = []
        for row_num in self.item_view_order():
            key = model.item(row_num, 0).text()
            value = model.item(row_num, 1).text()
            if re.fullmatch("[a-zA-Z]([a-zA-Z0-9_-])*", key) is None:
                raise FilterValidationException(
                    self.__class__.__name__, "Invalid Rule-ID", f"ID='{key}'")
            elif key in seen:
                raise FilterValidationException(
                    self.__class__.__name__, "Duplicate Rule-ID", f"ID='{key}'")
            elif key.endswith("_regexp"):
                try:
                    re.compile(value)
                except Exception as e:
                    raise FilterValidationException(
                        self.__class__.__name__, "Invalid Regular Expression", f"\n{key}={value}\n\n{str(e)}")
            seen.append(key)
        return True

    def copy_from_config(self, config_section: Mapping[str, str]):
        model = self.model()
        if model.rowCount() > 0:
            model.removeRows(0, model.rowCount())
        row = 0
        enable_item_map: Mapping[str, QStandardItem] = {}
        # Step one - first gather the patterns and create a row for each one
        for key, value in config_section.items():
            if key.endswith("_enabled"):
                pass
            else:
                key_item = self.create_rule_id_item(key)
                key_enabled = key + "_enabled"
                if key_enabled in config_section:
                    if config_section[key_enabled].strip().lower() != 'yes':
                        key_item.setCheckState(Qt.Unchecked)
                model.setItem(row, 0, key_item)
                value_item = QStandardItem(value)
                value_item.setToolTip(self.pattern_tooltip)
                model.setItem(row, 1, QStandardItem(value_item))
                row += 1

    def copy_to_config(self, config_section: Mapping[str, str]):
        debug(f'table order = {self.item_view_order()} ')
        for key in config_section.keys():
            del config_section[key]
        model = self.model()
        for row_num in self.item_view_order():
            key = model.item(row_num, 0).text()
            if key.strip() == '':
                continue
            value = model.item(row_num, 1).text()
            config_section[key] = value
            if model.item(row_num, 0).checkState() == Qt.Unchecked:
                config_section[key + "_enabled"] = "no"

    select_flags = QItemSelectionModel.Clear | QItemSelectionModel.Rows | QItemSelectionModel.SelectCurrent | QItemSelectionModel.Rows

    def add_new_rule(self, rule_id: str = '', pattern: str = ''):
        model = self.model()
        selected_row_indices = self.selectionModel().selectedRows()
        if len(selected_row_indices) > 0:
            index = sorted(selected_row_indices)[0]
            model.insertRow(index.row(), [self.create_rule_id_item(rule_id), QStandardItem(pattern)])
            self.scrollTo(index)
            self.clearSelection()
            self.selectRow(index.row())
        else:
            model.appendRow([self.create_rule_id_item(rule_id), QStandardItem(pattern)])
            self.scrollToBottom()
            self.selectRow(model.rowCount() - 1)

    def delete_selected_rules(self):
        model = self.model()
        selected_row_indices = self.selectionModel().selectedRows()
        if len(selected_row_indices) == 0:
            message = QMessageBox(self)
            message.setWindowTitle(tr('Delete'))
            message.setText(
                tr("Cannot delete, no rows selected.\nClick in the left margin to select some rows."))
            message.setIcon(QMessageBox.Critical)
            message.setStandardButtons(QMessageBox.Ok)
            message.exec()
            return
        # Reverse the order so we delete from bottom up preserving the positions of yet to be removed rows.
        for index in sorted(selected_row_indices, reverse=True):
            model.removeRow(index.row())
            if model.rowCount() > index.row():
                self.selectRow(model.rowCount())
            else:
                self.selectRow(model.rowCount() - 1)


class JournalWatcherTask(QThread):
    signal_new_entry = pyqtSignal(dict)

    def __init__(self) -> None:
        super().__init__()
        self.watcher = JournalWatcher(self)

    def is_notifying(self) -> bool:
        return self.watcher.is_notifying()

    def enable_notifications(self, enable: bool):
        self.watcher.enable_notifications(enable)

    def run(self) -> None:
        self.watcher.watch_journal()

    def new_journal_entry(self, journal_entry: Mapping):
        self.signal_new_entry.emit(journal_entry)


def title(widget: QLabel) -> QLabel:
    widget.setStyleSheet("font-weight: normal;font-size: 13pt;")
    return widget


class ConfigPanel(QWidget):

    def __init__(self, tab_change: Callable, parent: QWidget):
        super().__init__(parent=parent)

        layout = QVBoxLayout()
        self.setLayout(layout)
        tabs = QTabWidget()
        self.tabs = tabs

        config = Config()
        config.refresh()

        options_panel = OptionsTab(config['options'], parent=self)

        match_panel = FilterPanel(
            config['match'],
            tooltip=tr("Only issue notifications for journal-entry messages that match one of these rules."),
            parent=parent)

        ignore_panel = FilterPanel(
            config['ignore'],
            tooltip=tr("Ignore journal-entry messages that match any of these rules."),
            parent=parent)

        button_box = QWidget()
        button_box_layout = QGridLayout()
        button_box.setLayout(button_box_layout)
        apply_button = QPushButton(tr("Apply"))
        revert_button = QPushButton(tr("Revert"))

        button_box_layout.addWidget(apply_button, 0, 0)
        button_box_layout.addWidget(revert_button, 0, 1)
        button_box_layout.setColumnMinimumWidth(3, 200)

        def save_action():
            debug("Apply")
            try:
                if match_panel.is_valid() and ignore_panel.is_valid():
                    options_panel.copy_to_config(config['options'])
                    match_panel.copy_to_config(config['match'])
                    ignore_panel.copy_to_config(config['ignore'])
                    config.save()
                    match_panel.clear_selection()
                    ignore_panel.clear_selection()
                    message = QMessageBox(self)
                    message.setWindowTitle(tr('Applied'))
                    message.setText(tr('Changes are now active.'))
                    message.setIcon(QMessageBox.Information)
                    message.setStandardButtons(QMessageBox.Ok)
                    # message.setDetailedText()
                    message.exec()
                    debug(f'ok')
            except FilterValidationException as e:
                e_title, summary, text = e.args
                message = QMessageBox(self)
                message.setWindowTitle(e_title)
                message.setText(f"{tr('Cannot apply changes.')}\n{summary}\n{text}")
                message.setIcon(QMessageBox.Critical)
                message.setStandardButtons(QMessageBox.Ok)
                # message.setDetailedText()
                message.exec()

        apply_button.clicked.connect(save_action)

        def revert_action():
            debug("revert")
            before = pickle.dumps(config)
            tmp = pickle.loads(before)
            options_panel.copy_to_config(tmp['options'])
            match_panel.copy_to_config(tmp['match'])
            ignore_panel.copy_to_config(tmp['ignore'])
            after = pickle.dumps(tmp)
            if before == after:
                revert_message = QMessageBox(self)
                revert_message.setText(tr('There are no unapplied changes, there is nothing to revert.'))
                revert_message.setIcon(QMessageBox.Warning)
                revert_message.setStandardButtons(QMessageBox.Ok)
                revert_message.exec()
                return
            else:
                revert_message = QMessageBox(self)
                revert_message.setText(tr('There are unapplied changes, revert and loose all changes?'))
                revert_message.setIcon(QMessageBox.Question)
                revert_message.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
                if revert_message.exec() == QMessageBox.Cancel:
                    return
            info("reverting unsaved edits")
            options_panel.copy_from_config(config['options'])
            match_panel.copy_from_config(config['match'])
            ignore_panel.copy_from_config(config['ignore'])
            match_panel.clear_selection()
            ignore_panel.clear_selection()

        revert_button.clicked.connect(revert_action)

        tabs.addTab(ignore_panel, tr("Ignore Filters"))
        tabs.addTab(match_panel, tr("Match Filters"))
        tabs.addTab(options_panel, tr("Options"))
        tabs.setCurrentIndex(0)

        layout.addWidget(title(QLabel("Configuration")))
        layout.addWidget(tabs)
        layout.addWidget(button_box)

        tabs.currentChanged.connect(tab_change)

        options_panel.copy_from_config(config['options'])
        match_panel.copy_from_config(config['match'])
        ignore_panel.copy_from_config(config['ignore'])
        # self.make_visible()

    def make_visible(self):
        """
        If the dialog exists(), call this to make it visible by raising it.
        Internal, used by the class method show_existing_dialog()
        """
        self.show()
        self.raise_()
        self.activateWindow()

    def add_rule(self, rule_id, pattern) -> None:
        if isinstance(self.tabs.currentWidget(), FilterPanel):
            self.tabs.currentWidget().add_rule(rule_id, pattern)
        else:
            raise TypeError("Was expecting FilterPanel")

    def delete_rules(self) -> None:
        if isinstance(self.tabs.currentWidget(), FilterPanel):
            self.tabs.currentWidget().delete_rules()
        else:
            raise TypeError("Was expecting FilterPanel")


class MainToolBar(QToolBar):

    def __init__(self,
                 run_func: Callable, notify_func: Callable,
                 add_func: Callable, del_func: Callable,
                 search_func: Callable,
                 parent: QWidget):
        super().__init__(parent=parent)
        # main_tool_bar.setFixedHeight(80)
        # main_tool_bar.setIconSize(QSize(30,30))
        self.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)
        self.icon_run_enabled = create_icon_from_svg_string(TOOLBAR_RUN_ENABLED_SVG)
        self.icon_run_disabled = create_icon_from_svg_string(TOOLBAR_RUN_DISABLED_SVG)
        self.icon_notifier_enabled = create_icon_from_svg_string(TOOLBAR_NOTIFIER_ENABLED_SVG)
        self.icon_notifier_disabled = create_icon_from_svg_string(TOOLBAR_NOTIFIER_DISABLED_SVG)
        self.run_action = self.addAction(self.icon_run_enabled, tr("Run"), run_func)
        self.run_action.setToolTip(tr("Start/stop monitoring the journal feed."))
        self.stop_action = self.addAction(create_icon_from_svg_string(TOOLBAR_STOP_SVG), tr("Stop"), run_func)
        self.stop_action.setToolTip(tr("Stop monitoring the journal feed."))
        self.addSeparator()
        self.notifier_action = self.addAction(self.icon_notifier_enabled, "notify", notify_func)
        self.notifier_action.setToolTip(tr("Enable/disable desktop notifications."))
        self.addSeparator()
        self.add_filter_action = self.addAction(create_icon_from_svg_string(TOOLBAR_ADD_FILTER_SVG), "add", add_func)
        self.add_filter_action.setIconText(tr("New filter"))
        self.add_filter_action.setToolTip(
            tr("Add a new filter above the selected filter or at the end if no filter is selected.") + "\n" +
            tr("Select a filter tab and optionally click in its left margin to select an insertion point."))
        self.del_filter_action = self.addAction(create_icon_from_svg_string(TOOLBAR_DEL_FILTER_SVG), "add", del_func)
        self.del_filter_action.setIconText(tr("Delete filter"))
        self.del_filter_action.setToolTip(
            tr("Delete selected filter.") + "\n" +
            tr("Select a filter tab and click in its left margin to select a filter to delete."))
        self.addSeparator()
        search_input = QLineEdit()
        search_input.addAction(ICON_SEARCH_JOURNAL, QLineEdit.LeadingPosition)
        search_input.setToolTip(tr("Incrementally search and select journal entries.\nSearches all fields."))
        self.addWidget(search_input)
        search_input.textChanged.connect(search_func)
        spacer = QWidget()
        spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.addWidget(spacer)
        self.addAction(ICON_HELP_CONTENTS, tr('Help'), HelpDialog.invoke)
        self.addAction(ICON_HELP_ABOUT, tr('About'), AboutDialog.invoke)

    def configure_run_action(self, running: bool) -> None:
        if running:
            self.run_action.setIcon(self.icon_run_enabled)
            self.run_action.setIconText(tr("Running"))
            self.stop_action.setEnabled(True)
        else:
            self.run_action.setIcon(self.icon_run_disabled)
            self.run_action.setIconText(tr("Stopped"))
            self.stop_action.setEnabled(False)

    def configure_notifier_action(self, notifying: bool) -> None:
        if notifying:
            self.notifier_action.setIcon(self.icon_notifier_enabled)
            self.notifier_action.setIconText(tr('Notifying  '))
        else:
            self.notifier_action.setIcon(self.icon_notifier_disabled)
            self.notifier_action.setIconText(tr('Discarding'))

    def configure_filter_actions(self, enable: bool) -> None:
        self.add_filter_action.setEnabled(enable)
        self.del_filter_action.setEnabled(enable)


class MainContextMenu(QMenu):

    def __init__(self, run_func: Callable, notify_func: Callable, quit_func: Callable, parent: QWidget):
        super().__init__(parent=parent)
        self.icon_notifier_enabled = create_icon_from_svg_string(TOOLBAR_NOTIFIER_ENABLED_SVG)
        self.icon_notifier_disabled = create_icon_from_svg_string(TOOLBAR_NOTIFIER_DISABLED_SVG)
        self.listen_action = self.addAction(ICON_CONTEXT_MENU_LISTENING_DISABLE,
                                            tr("Stop journal monitoring"),
                                            run_func)
        self.notifier_action = self.addAction(self.icon_notifier_disabled,
                                              tr("Disable notifications"),
                                              notify_func)
        self.addAction(ICON_HELP_ABOUT,
                       tr('About'),
                       AboutDialog.invoke)
        self.addAction(ICON_HELP_CONTENTS,
                       tr('Help'),
                       HelpDialog.invoke)
        self.addSeparator()
        self.addAction(ICON_APPLICATION_EXIT,
                       tr('Quit'),
                       quit_func)

    def configure_run_action(self, running: bool) -> None:
        if running:
            self.listen_action.setText(tr("Stop journal monitoring"))
            self.listen_action.setIcon(ICON_CONTEXT_MENU_LISTENING_DISABLE)
        else:
            self.listen_action.setText(tr("Resume journal monitoring"))
            self.listen_action.setIcon(ICON_CONTEXT_MENU_LISTENING_ENABLE)

    def configure_notifier_action(self, notifying: bool) -> None:
        if notifying:
            self.notifier_action.setText(tr("Disable notifications"))
            self.notifier_action.setIcon(self.icon_notifier_disabled)
        else:
            self.notifier_action.setText(tr("Enable notifications"))
            self.notifier_action.setIcon(self.icon_notifier_enabled)


class MainWindow(QMainWindow):

    def __init__(self, app: QApplication):
        super().__init__()

        journal_watcher_task = JournalWatcherTask()

        app_name = tr('Jouno')
        app.setWindowIcon(create_icon_from_svg_string(JOUNO_ICON_LIGHT_SVG))
        app.setApplicationDisplayName(app_name)
        app.setApplicationVersion(JOUNO_VERSION)

        self.setWindowTitle(tr("Running"))

        def enable_listener(enable: bool) -> None:
            if enable:
                self.setWindowTitle(tr("Running"))
                journal_watcher_task.start()
                while not journal_watcher_task.isRunning():
                    time.sleep(0.2)
                tray.setIcon(create_icon_from_svg_string(JOUNO_ICON_SVG))
                tray.setToolTip(f"{tr('Running')} \u2014 {app_name}")
                tool_bar.configure_run_action(enable)
                app_context_menu.configure_run_action(enable)
            else:
                self.setWindowTitle(tr("Stopped"))
                journal_watcher_task.requestInterruption()
                while journal_watcher_task.isRunning():
                    time.sleep(0.2)
                tray.setIcon(ICON_TRAY_LISTENING_DISABLED)
                tray.setToolTip(f"{tr('Stopped')} \u2014 {app_name}")
                tool_bar.configure_run_action(enable)
                app_context_menu.configure_run_action(enable)

        def toggle_listener() -> None:
            enable_listener(not journal_watcher_task.isRunning())

        def enable_notifier(enable: bool) -> None:
            if enable:
                journal_watcher_task.enable_notifications(True)
                tool_bar.configure_notifier_action(enable)
                app_context_menu.configure_notifier_action(enable)
            else:
                journal_watcher_task.enable_notifications(False)
                tool_bar.configure_notifier_action(enable)
                app_context_menu.configure_notifier_action(enable)

        def toggle_notifier():
            enable_notifier(not journal_watcher_task.is_notifying())

        def quit_app():
            journal_watcher_task.requestInterruption()
            app.quit()

        def tab_change(tab_number):
            tool_bar.configure_filter_actions(tab_number == 0 or tab_number == 1)

        self.main_panel = MainCentralPanel(
            journal_watcher_task=journal_watcher_task, tab_change=tab_change, parent=self)
        self.setCentralWidget(self.main_panel)

        tool_bar = MainToolBar(
            run_func=toggle_listener, notify_func=toggle_notifier,
            add_func=self.main_panel.add_filter, del_func=self.main_panel.delete_filters,
            search_func=self.main_panel.search_select_journal,
            parent=self)
        self.addToolBar(tool_bar)

        app_context_menu = MainContextMenu(
            run_func=toggle_listener, notify_func=toggle_notifier, quit_func=quit_app, parent=self)

        tray = QSystemTrayIcon()
        tray.setIcon(create_icon_from_svg_string(JOUNO_ICON_SVG))
        tray.setContextMenu(app_context_menu)

        def show_window():
            if self.isVisible():
                self.hide()
            else:
                # Use the mouse pos as a guess to where the system tray is.  The Linux Qt x,y geometry returned by
                # the tray icon is 0,0, so we can't use that.
                p = QCursor.pos()
                wg = self.geometry()
                # Also try to cope with the tray not being at the bottom right of the screen.
                x = p.x() - wg.width() if p.x() > wg.width() else p.x()
                y = p.y() - wg.height() if p.y() > wg.height() else p.y()
                self.setGeometry(x, y, wg.width(), wg.height())
                self.show()
                # Attempt to force it to the top with raise and activate
                self.raise_()
                self.activateWindow()

        tray.activated.connect(show_window)
        tray.setVisible(True)
        enable_listener(True)
        enable_notifier(True)
        rc = app.exec_()
        if rc == 999:  # EXIT_CODE_FOR_RESTART:
            QProcess.startDetached(app.arguments()[0], app.arguments()[1:])

    def add_filter(self):
        self.main_panel.add_rule()


class MainCentralPanel(QWidget):

    def __init__(self, journal_watcher_task: JournalWatcherTask, tab_change: Callable, parent: QWidget):
        super().__init__(parent=parent)
        # self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.setWindowTitle(tr('Control Panel'))
        self.setMinimumWidth(1200)
        self.setMinimumHeight(1000)
        splitter = QSplitter()
        splitter.setOrientation(Qt.Vertical)
        layout = QVBoxLayout()
        splitter.setStyleSheet("QSplitter::handle{background: #333333;}")

        self.journal_panel = JournalPanel(journal_watcher_task=journal_watcher_task, parent=self)
        splitter.addWidget(self.journal_panel)

        self.config_panel = ConfigPanel(tab_change=tab_change, parent=self)
        splitter.addWidget(self.config_panel)

        layout.addWidget(splitter)
        self.setLayout(layout)

    def add_filter(self):
        journal_entry = self.journal_panel.get_selected_journal_entry()
        if journal_entry is None:
            message = ''
        else:
            # ts = journal_entry['__REALTIME_TIMESTAMP']
            # rule_id = f"r{ts:%Y%m%d-%H%M%S-%f}"
            message = journal_entry['MESSAGE']
        self.config_panel.add_rule('<new_id>', message)

    def delete_filters(self):
        self.config_panel.delete_rules()

    def search_select_journal(self, text:str):
        self.journal_panel.search_select_journal(text)


class JournalPanel(QWidget):

    def __init__(self, journal_watcher_task: JournalWatcherTask, parent: QWidget):
        super().__init__(parent=parent)

        self.table_view = JournalTableView(journal_watcher_task)

        # TODO add a test rules button that pops up a testing dialog with an input field.
        layout = QVBoxLayout(self)
        self.title = title(QLabel(tr("Recently notified")))
        layout.addWidget(self.title)
        layout.addWidget(self.table_view)

        self.setLayout(layout)

    def set_title(self, value: str):
        self.title.setText(str)

    def get_selected_journal_entry(self):
        indexes = self.table_view.selectedIndexes()
        if indexes is None or len(indexes) == 0:
            return None
        return self.table_view.model().get_journal_entry(indexes[-1].row())

    def get_last_journal_entry(self):
        if self.table_view.model().rowCount() == 0:
            return None
        return self.table_view.model().get_journal_entry(self.table_view.model().rowCount() - 1)

    def search_select_journal(self, text:str):
        self.table_view.clearSelection()
        model = self.table_view.model()
        if text.strip() != '':
            for row_num in range(model.rowCount()):
                journal_entry = model.get_journal_entry(row_num)
                # Assume case insensitive if all text is in lower case.
                entry_text = str(journal_entry).lower() if text.islower() else str(journal_entry)
                if text in entry_text:
                    self.table_view.selectRow(row_num)
                    self.table_view.scrollTo(model.index(row_num,0))


class JournalTableView(QTableView):

    def __init__(self, journal_watcher_task: JournalWatcherTask):
        super().__init__()
        self.setToolTip(tr("Double click to view the complete journal entry.") + "\n" +
                        tr("Control-C to copy a selected field's text."))
        self.setModel(JournalTableModel(number_of_rows=0))
        self.setDragDropOverwriteMode(False)
        self.resizeColumnsToContents()
        self.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.setSelectionMode(QAbstractItemView.MultiSelection)
        self.setColumnWidth(0, 8 * 14)
        self.setColumnWidth(1, 10 * 14)
        self.setColumnWidth(2, 10 * 14)
        self.setColumnWidth(3, 5 * 14)
        self.horizontalHeader().setSectionResizeMode(4, QHeaderView.Stretch)
        self.horizontalHeader().setDefaultAlignment(Qt.AlignLeft)
        self.horizontalHeader().setStyleSheet(TABLE_HEADER_STYLE)
        self.setItemDelegate(JournalEntryDelegate(self.model()))
        self.setEditTriggers(QAbstractItemView.SelectedClicked)
        # self.setGridStyle(Qt.NoPen)
        self.setShowGrid(False)

        def view_journal_entry(index: QModelIndex):
            entry_dialog = JournalEntryDialogPlain(self, self.model().get_journal_entry(index.row()))
            entry_dialog.show()

        self.doubleClicked.connect(view_journal_entry)

        def new_journal_entry(journal_entry):
            self.model().new_journal_entry(journal_entry)
            self.scrollToBottom()

        journal_watcher_task.signal_new_entry.connect(new_journal_entry)


class JournalTableModel(QStandardItemModel):

    def __init__(self, number_of_rows: int):
        super().__init__(number_of_rows, 5)
        self.icon_cache = {}
        self.journal_entries = []
        self.setHorizontalHeaderLabels(
            [tr("Time"), tr("Host"), tr("Source"), tr("PID"), tr("Message")])

    def get_journal_entry(self, row: int):
        return self.journal_entries[row]

    def new_journal_entry(self, journal_entry):
        while self.rowCount() > 100:
            self.removeRow(0)
            self.journal_entries.pop(0)

        def align_right(item: QStandardItem):
            item.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
            return item

        def selectable(item: QStandardItem):
            item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled | Qt.ItemIsEditable)
            return item

        def setIcon(item: QStandardItem):
            priority = journal_entry['PRIORITY'] if 'PRIORITY' in journal_entry else Priority.NOTICE.value
            if not Priority.EMERGENCY.value <= priority <= Priority.DEBUG.value:
                priority = Priority.NOTICE.value
            notification_icon_name = NOTIFICATION_ICONS[Priority(priority)]
            if notification_icon_name in self.icon_cache:
                icon = self.icon_cache[notification_icon_name]
            else:
                icon = QIcon.fromTheme(notification_icon_name)
                self.icon_cache[notification_icon_name] = icon
            item.setIcon(icon)
            return item

        self.journal_entries.append(journal_entry)

        self.appendRow(
            [
                selectable(align_right(QStandardItem(f"{journal_entry['__REALTIME_TIMESTAMP']:%H:%M:%S}"))),
                selectable(QStandardItem(journal_entry['_HOSTNAME'])),
                # TODO smarter choice of source value
                selectable(QStandardItem(journal_entry['_COMM'] if '_COMM' in journal_entry else 'unknown')),
                # TODO smarter choice when _PID is not present.
                selectable(align_right(QStandardItem(str(journal_entry['_PID'] if '_PID' in journal_entry else '')))),
                setIcon(selectable(QStandardItem(journal_entry['MESSAGE'])))
            ])


class JournalEntryDelegate(QStyledItemDelegate):

    def createEditor(self, parent, option, index):
        line_edit = QLineEdit(parent)
        # Makes it behave line a normal readonly text entry (unlike making the whole table read only).
        line_edit.setReadOnly(True)
        return line_edit


class JournalEntryDialogPlain(QDialog):

    def __init__(self, parent, journal_entry):
        super().__init__(parent)

        self.setWindowTitle(tr(f"Journal Entry {journal_entry['__REALTIME_TIMESTAMP']}"))
        layout = QVBoxLayout()

        text_view = QTextEdit()
        text_view.setFont(QFontDatabase.systemFont(QFontDatabase.FixedFont))
        text_view.setReadOnly(True)
        text_view.setLineWrapMode(QTextEdit.LineWrapMode.NoWrap)
        text = tr(f"Journal Entry {journal_entry['__REALTIME_TIMESTAMP']}\n\n")
        for row, (k, v) in enumerate(sorted(list(journal_entry.items()))):
            text += f"{k:25}: {str(v)}\n"
        text_view.setText(text)

        layout.addWidget(text_view)

        self.setLayout(layout)
        self.setMinimumWidth(1000)
        self.setMinimumHeight(800)
        self.adjustSize()

        # .show() is non-modal, .exec() is modal
        self.show()

        def copy_to_clipboard():
            nonlocal floating_feedback_flip
            QGuiApplication.clipboard().setText(text_view.toPlainText())
            floating_copy_button.clearFocus()
            floating_copy_button.setIconSize(QSize(50,50) if floating_feedback_flip else QSize(48, 48))
            floating_feedback_flip= not floating_feedback_flip
            floating_copy_button.repaint()

        floating_feedback_flip = True
        floating_copy_button = QPushButton(self)
        floating_copy_button.setStyleSheet("QPushButton { background-color: transparent; border: 0px }")
        floating_copy_button.setIcon(ICON_COPY_TO_CLIPBOARD)
        floating_copy_button.setGeometry(self.width() - 75, 25, 40, 40);
        floating_copy_button.setIconSize(QSize(48,48))
        floating_copy_button.setToolTip(tr("Copy to clipboard"))
        floating_copy_button.show()
        floating_copy_button.clicked.connect(copy_to_clipboard)


class DialogSingletonMixin:
    """
    A mixin that can augment a QDialog or QMessageBox with code to enforce a singleton UI.
    For example, it is used so that only ones settings editor can be active at a time.
    """
    _dialogs_map = {}
    debug = False

    def __init__(self) -> None:
        """Registers the concrete class as a singleton so it can be reused later."""
        super().__init__()
        class_name = self.__class__.__name__
        if class_name in DialogSingletonMixin._dialogs_map:
            raise TypeError(f"ERROR: More than one instance of {class_name} cannot exist.")
        if DialogSingletonMixin.debug:
            print(f'DEBUG: SingletonDialog created for {class_name}')
        DialogSingletonMixin._dialogs_map[class_name] = self

    def closeEvent(self, event) -> None:
        """Subclasses that implement their own closeEvent must call this closeEvent to deregister the singleton"""
        class_name = self.__class__.__name__
        if DialogSingletonMixin.debug:
            print(f'DEBUG: SingletonDialog remove {class_name}')
        del DialogSingletonMixin._dialogs_map[class_name]
        event.accept()

    def make_visible(self):
        """
        If the dialog exists(), call this to make it visible by raising it.
        Internal, used by the class method show_existing_dialog()
        """
        self.show()
        self.raise_()
        self.activateWindow()

    @classmethod
    def show_existing_dialog(cls: Type):
        """If the dialog exists(), call this to make it visible by raising it."""
        class_name = cls.__name__
        if DialogSingletonMixin.debug:
            print(f'DEBUG: SingletonDialog show existing {class_name}')
        instance = DialogSingletonMixin._dialogs_map[class_name]
        instance.make_visible()

    @classmethod
    def exists(cls: Type) -> bool:
        """Returns true if the dialog has already been created."""
        class_name = cls.__name__
        if DialogSingletonMixin.debug:
            print(f'DEBUG: SingletonDialog exists {class_name} {class_name in DialogSingletonMixin._dialogs_map}')
        return class_name in DialogSingletonMixin._dialogs_map


class AboutDialog(QMessageBox, DialogSingletonMixin):

    @staticmethod
    def invoke():
        if AboutDialog.exists():
            AboutDialog.show_existing_dialog()
        else:
            AboutDialog()

    def __init__(self):
        super().__init__()
        self.setWindowTitle(tr('About'))
        self.setTextFormat(Qt.AutoText)
        self.setText(tr('About jouno'))
        self.setInformativeText(tr(ABOUT_TEXT))
        self.setIcon(QMessageBox.Information)
        self.exec()


class HelpDialog(QDialog, DialogSingletonMixin):

    @staticmethod
    def invoke():
        if HelpDialog.exists():
            HelpDialog.show_existing_dialog()
        else:
            HelpDialog()

    def __init__(self):
        super().__init__()
        self.setWindowTitle(tr('Help'))
        layout = QVBoxLayout()
        markdown_view = QTextEdit()
        markdown_view.setReadOnly(True)
        markdown_view.setMarkdown(__doc__)
        layout.addWidget(markdown_view)
        self.setLayout(layout)
        # TODO maybe compute a minimum from the actual screen size
        self.setMinimumWidth(1400)
        self.setMinimumHeight(1000)
        # .show() is non-modal, .exec() is modal
        self.make_visible()


class ContextMenu(QMenu):

    def __init__(self,
                 about_action=None, help_action=None, listen_action=None, config_action=None,
                 quit_action=None) -> None:
        super().__init__()

        self.play_pause_action = self.addAction(
            ICON_CONTEXT_MENU_LISTENING_DISABLE,
            tr('Pause'),
            listen_action)
        self.addAction(ICON_HELP_ABOUT,
                       tr('About'),
                       about_action)
        self.addAction(ICON_HELP_CONTENTS,
                       tr('Help'),
                       help_action)
        self.addSeparator()
        self.addAction(ICON_APPLICATION_EXIT,
                       tr('Quit'),
                       quit_action)


def exception_handler(e_type, e_value, e_traceback):
    """Overarching error handler in case something unexpected happens."""
    print("ERROR:\n", ''.join(traceback.format_exception(e_type, e_value, e_traceback)))
    alert = QMessageBox()
    alert.setText(tr('Error: {}').format(''.join(traceback.format_exception_only(e_type, e_value))))
    alert.setInformativeText(tr('Unexpected error'))
    alert.setDetailedText(
        tr('Details: {}').format(''.join(traceback.format_exception(e_type, e_value, e_traceback))))
    alert.setIcon(QMessageBox.Critical)
    alert.exec()
    QApplication.quit()


def install_as_desktop_application(uninstall: bool = False):
    """Self install this script in the current Linux user's bin directory and desktop applications->settings menu."""
    desktop_dir = Path.home().joinpath('.local', 'share', 'applications')
    icon_dir = Path.home().joinpath('.local', 'share', 'icons')
    if not desktop_dir.exists():
        print(f"ERROR: No desktop directory is present:{desktop_dir.as_posix()}"
              " Cannot proceed - is this a non-standard desktop?")
        return

    bin_dir = Path.home().joinpath('bin')
    if not bin_dir.is_dir():
        print(f"WARNING: creating:{bin_dir.as_posix()}")
        os.mkdir(bin_dir)

    if not icon_dir.is_dir():
        print(f"WARNING: creating:{icon_dir.as_posix()}")
        os.mkdir(icon_dir)

    installed_script_path = bin_dir.joinpath("jouno")
    desktop_definition_path = desktop_dir.joinpath("jouno.desktop")
    icon_path = icon_dir.joinpath("jouno.png")

    if uninstall:
        os.remove(installed_script_path)
        print(f'INFO: removed {installed_script_path.as_posix()}')
        os.remove(desktop_definition_path)
        print(f'INFO: removed {desktop_definition_path.as_posix()}')
        os.remove(icon_path)
        print(f'INFO: removed {icon_path.as_posix()}')
        return

    if installed_script_path.exists():
        print(f"WARNING: skipping installation of {installed_script_path.as_posix()}, it is already present.")
    else:
        source = open(__file__).read()
        source = source.replace("#!/usr/bin/python3", '#!' + sys.executable)
        print(f'INFO: creating {installed_script_path.as_posix()}')
        open(installed_script_path, 'w').write(source)
        print(f'INFO: chmod u+rwx {installed_script_path.as_posix()}')
        os.chmod(installed_script_path, stat.S_IRWXU)

    if desktop_definition_path.exists():
        print(f"WARNING: skipping installation of {desktop_definition_path.as_posix()}, it is already present.")
    else:
        print(f'INFO: creating {desktop_definition_path.as_posix()}')
        desktop_definition = textwrap.dedent(f"""
            [Desktop Entry]
            Type=Application
            Exec={installed_script_path.as_posix()}
            Name=jouno
            GenericName=juno
            Comment=A Systemd-Journal to Freedesktop-Notifications forwarder.
            Icon={icon_path.as_posix()}
            Categories=Qt;System;Monitor;System;
            """)
        open(desktop_definition_path, 'w').write(desktop_definition)

    if icon_path.exists():
        print(f"WARNING: skipping installation of {icon_path.as_posix()}, it is already present.")
    else:
        print(f'INFO: creating {icon_path.as_posix()}')
        create_pixmap_from_svg_string(JOUNO_ICON_SVG).save(icon_path.as_posix())

    print('INFO: installation complete. Your desktop->applications->system should now contain jouno')


def parse_args():
    args = sys.argv[1:]
    parser = argparse.ArgumentParser(
        description="A Systemd-Journal to Freedesktop-Notifications forwarder",
        formatter_class=argparse.RawTextHelpFormatter)
    parser.epilog = textwrap.dedent(f"""
            """)
    parser.add_argument('--detailed-help', default=False, action='store_true',
                        help='Detailed help (in markdown format).')
    parser.add_argument('--debug', default=False, action='store_true', help='enable debug output to stdout')
    parser.add_argument('--install', action='store_true',
                        help="installs the jouno application in the current user's path and desktop application menu.")
    parser.add_argument('--uninstall', action='store_true',
                        help='uninstalls the jouno application menu file and script for the current user.')
    parsed_args = parser.parse_args(args=args)
    if parsed_args.install:
        install_as_desktop_application()
        sys.exit()
    if parsed_args.uninstall:
        install_as_desktop_application(uninstall=True)
        sys.exit()
    if parsed_args.detailed_help:
        print(__doc__)
        sys.exit()


def main():
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    sys.excepthook = exception_handler
    app = QApplication(sys.argv)
    args = parse_args()
    MainWindow(app)


if __name__ == '__main__':
    main()
