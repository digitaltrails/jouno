#!/usr/bin/python3
"""
jouno: Journal notifications forwarder
======================================

A Systemd-Journal to Freedesktop-Notifications forwarder with burst-handling and filtering.

Usage:
======

        jouno [-h]
                     [--about] [--detailed-help]
                     [--install] [--uninstall]

Optional arguments:
-------------------

      -h, --help            show this help message and exit
      --detailed-help       full help in markdown format
      --about               about jouno
      --install             installs the jouno in the current user's path and desktop application menu.
      --uninstall           uninstalls the jouno application menu file and script for the current user.

Description
===========

This software is currently pre-release, It is feature complete and quite usable but may lack some polish.

``jouno`` is system-tray application for monitoring the ``systemd-journal.`` It raises selected
entries as desktop-notifications.

The application monitors the ``systemd-journal`` for new entries, filters them, and forwards them as
standard ``freedesktop dbus notifications``.  Most linux desktops present these notifications
as individual popup messages.

Bursts of messages are handled by bundling them in to a single summarising notification.

``jouno`` is a tool designed to improve awareness of background activity by monitoring
the journal and raising interesting journal-entries as desktop notifications.  Possibilities for
it use include:

 * Monitoring specific jobs, such as the progress of the daily backups.
 * Watching for specific events, such as background core dumps.
 * Investigating desktop actions that raise journal log entries.
 * Discovering unnecessary daemon activity and unnecessary services.
 * Notifying access attempts, such as su, ssh, samba, or pam events.
 * Prevention of undesirable desktop activity, such as shutting down during the backups.
 * Detecting hardware events.
 * Raising general awareness of what is going on in the background.

I have previously released a gist [notify-desktop](https://gist.github.com/digitaltrails/26aad3282d8739db1de8bc2e59c812eb)
that allows root batch-jobs, such as my daily backups, to raise notifications for the current desktop
user, but ``notify-desktop`` only covers my own code.  ``jouno`` allows me to watch for and monitor any
jobs on the system and potentially removes the need for my jobs to use my ``notify-desktop`` script.

Configuration
=============

Clicking on the ``jouno`` system-tray icon brings up an ``options and filters`` panel which includes three
tabs:

  1. Options: settings that adjust how to display messages and how to collate of bursts af messages

  2. Match Filters: filters that restrict notifications to only journal entries they match.

  3. Ignore Filters: filters that restrict notifications by ignoring journal entries they match.

Match filtering is most useful when only minimal journal entries are of interest and the other entries aren't
of interest.  For example, a match-filter might be set for core-dump journal entries only.

Ignore filtering is most useful when almost any journal entries might be of interest and only a few journal
items need to be ignored.  For example, if any unexpected messages might be of interest, ignore-filters could
be set up for any that are routine.

It's common to require a few ignore-filters to discard any messages generated by the desktop notification system
in response to notices being posted.

Match and Ignore Patterns
-------------------------

 * Journal entries are filtered by list of rules.  Each rule defines a ``Rule ID`` and a ``pattern.``

 * Each rule is identified by a ``Rule ID`` which is text identifier compliant with commonly accepted
   variable naming conventions, for example:
   ```
   my_id
   my-id
   myId21
   ```

 * Rule ID's that end with a ``_regexp`` suffix define a regular-expression pattern, while those that
   do not end in ``_regexp`` define a literal-text pattern. For example:
   ```
   my-id_rexp
   ```
   versus
   ```
   my-id
   ```

 * Patterns may match any fragment of text seen in actual journal entries.

 * Patterns may also match specific journal entry fields, for example:
   ```
   'SYSLOG_IDENTIFIER=su'
   '_GID=500',
   '_HOSTNAME=kosmos1'
   'PRIORITY=7',
   '_CMDLINE=/usr/bin/kded5'
   '_PID=2143',
   ```
   When attempting to match specific fields surround the pattern with single-quotes
   to ensure that complete values are matched, for example: ``'_GID=500'``  will
   only match the intended field and value, it won't match ``PARENT_GID=5000``.

   The list of possible field names can be found at:

      [https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html)

Config files
------------

The config files are in INI-format divided into a number of sections as outlined below::

        # The options section controls notice timeouts, burst treatment
        [options]
        # Polling interval, how often to wait for journal entries between checking for config changes
        poll_seconds = 2
        # Wait at lease burst_seconds before declaring a burst of messages to have finished
        burst_seconds = 5
        # Only show the the first burst_truncate_messages of a burst
        burst_truncate_messages = 3
        # Set journo messages to timeout/auto-dismiss after notification-seconds
        notification_seconds = 30
        # The maximum number of journal items to display in the "Recently notified" table.
        journal_history_max = 100
        # Run out of the system tray
        system_tray_enabled = yes
        # For debugging the application
        debug_enabled = yes

        [match]
        # Each filter rule has an id and the message text to match
        my_rule_id = forward journal entry if this string matches
        # Each filter rule can be disabled by a corresponding my_rule_id_enabled = no option
        my_rule_id_enabled = no
        # A filter id that ends in _regexp is treated as a python regular-expression
        my_other_rule_id_regexp = forward journal [Ee]ntry if this python-regexp matches

        [ignore]
        my_ignore_rule_id = ignore journal entry if this string matches
        my_ignore_other_rule_id_regexp = ignore [Jj]ournal entry if this python-regexp matches

The config files are optional, but some filtering of the journal is likely to be necessary.
``jouno`` copes with cascades and won't cause infinite cascades, but filtering may be necessary
to eliminate excessive bursts caused by the desktop when it processes the notifications generated
by jouno.

Prerequisites
=============

All the following runtime dependencies are likely to be available pre-packaged on any modern Linux distribution
(``jouno`` was originally developed on OpenSUSE Tumbleweed).

* python 3.8: ``journo`` is written in python and may depend on some features present only in 3.8 onward.
* python 3.8 QtPy: the python GUI library used by ``jouno``.
* python 3.8 systemd: python module for native access to the systemd facilities.
* python 3.8 dbus: python module for dbus used for issuing notifications

Dependency installation on ``OpenSUSE``::

        zypper install python38-QtPy python38-systemd python38-dbus


jouno Copyright (C) 2021 Michael Hamilton
===========================================

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, version 3.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along
with this program. If not, see <https://www.gnu.org/licenses/>.

**Contact:**  m i c h a e l   @   a c t r i x   .   g e n   .   n z

----------

"""

# DONE Add option for how many journal rows to show - if zero hide panel.
# DONE Add option for non-tray use.
# TODO Consider creating a separate full log browser making use of the journal API for search and random access.
# DONE Search 'recent' on toolbar
# TODO Display more fields in 'recent' - priority as icon perhaps.
# DONE https://specifications.freedesktop.org/icon-naming-spec/latest/
# TODO Position the GUI to the left so as not to be covered by alerts.
# TODO Smaller Apply/Revert button widths.
# TODO figure out why QIntValidator is only working approximately.
# DONE Unify treatment of icon loading.
# DONE Fix tray hover title

import argparse
import configparser
import os
import pickle
import re
import select
import signal
import stat
import sys
import textwrap
import time
import traceback
from enum import Enum
from functools import partial
from pathlib import Path
from typing import Mapping, Any, List, Type, Callable

import dbus
from PyQt5.QtCore import QCoreApplication, QProcess, Qt, pyqtSignal, QThread, QModelIndex, QItemSelectionModel, QSize, \
    QEvent, QSettings
from PyQt5.QtGui import QPixmap, QIcon, QImage, QPainter, QCursor, QStandardItemModel, QStandardItem, QIntValidator, \
    QFontDatabase, QGuiApplication, QCloseEvent, QPalette, QShowEvent
from PyQt5.QtSvg import QSvgRenderer
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QMessageBox, QLineEdit, QLabel, \
    QPushButton, QSystemTrayIcon, QMenu, QTextEdit, QDialog, QTabWidget, \
    QCheckBox, QGridLayout, QTableView, \
    QAbstractItemView, QHeaderView, QMainWindow, QSizePolicy, QStyledItemDelegate, QToolBar, QDockWidget, \
    QHBoxLayout, QStyleFactory, QDesktopWidget
from systemd import journal

JOUNO_VERSION = '0.9.6'

# The icons can either be:
#   1) str: named icons from the freedesktop theme which should all be available on most Linux desktops.
#      https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
#   1) bytes: SVG strings for any icons that are custom to this application.
# The load_icon() function dynamically figures out which so we can
# switch from one source to another without editing the code proper
# TODO: consider moving the icon definitions to a file read at startup.
ICON_HELP_ABOUT = "help-about"
ICON_HELP_CONTENTS = "help-contents"
ICON_APPLICATION_EXIT = "application-exit"
ICON_CONTEXT_MENU_LISTENING_ENABLE = "view-refresh"
ICON_CONTEXT_MENU_LISTENING_DISABLE = "process-stop"
ICON_TRAY_LISTENING_DISABLED = ICON_CONTEXT_MENU_LISTENING_DISABLE
ICON_COPY_TO_CLIPBOARD = "edit-copy"
ICON_SEARCH_JOURNAL = "system-search"
ICON_UNDOCK = "window-new"
ICON_DOCK = "window-close"
ICON_GO_NEXT = "go-down"
ICON_GO_PREVIOUS = "go-up"

ICON_BLACK_COLOR = b"#232629"
ICON_WHITE_COLOR = b"#f3f3f3"

ICON_JOUNO = b"""
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
 <path fill="#232629" style="fill:currentColor;fill-opacity:1;stroke:none" 
      d="M 4 2 L 4 3 L 13 3 L 13 13 L 4 13 L 4 14 L 13 14 L 14 14 L 14 3 L 14 2 L 7 2 z"
      class="ColorScheme-Text"
     />
 <path fill="#3491e1" style="fill-opacity:1;stroke:none" 
      d="M 8 6 L 8 8 L 12 8 L 12 7 L 8 7 z M 8 8 L 8 10 L 12 10 L 12 9 L 8 9 z M 8 11 L 8 12 L 12 12 L 12 11 L 10 11 z "

     />

</svg>
"""
ICON_JOUNO_LIGHT = ICON_JOUNO.replace(ICON_BLACK_COLOR, b'#bbbbbb')

ICON_TOOLBAR_RUN_DISABLED = b"""
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 22">
    <style type="text/css" id="current-color-scheme">
        .ColorScheme-Text {
            color:#232629;
        }
    </style>
    <path d="m3 3v16l16-8z" class="ColorScheme-Text" fill="currentColor"/>
</svg>
"""

ICON_TOOLBAR_RUN_ENABLED = ICON_TOOLBAR_RUN_DISABLED.replace(b"#232629;", b"#3daee9;")
ICON_TOOLBAR_STOP = b"""
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 22">
    <style type="text/css" id="current-color-scheme">
        .ColorScheme-Text {
            color:#da4453;
        }
    </style>
    <path d="m3 3h16v16h-16z" class="ColorScheme-Text" fill="currentColor"/>
</svg>
"""
ICON_TOOLBAR_NOTIFIER_ENABLED = b"""
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 22">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#379fd3;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none"
       d="M 3 4 L 3 16 L 6 20 L 6 17 L 6 16 L 19 16 L 19 4 L 3 4 z M 4 5 L 18 5 L 18 15 L 4 15 L 4 5 z M 16 6 L 9.5 12.25 L 7 10 L 6 11 L 9.5 14 L 17 7 L 16 6 z "
     class="ColorScheme-Text"
     />
</svg>
"""
ICON_TOOLBAR_NOTIFIER_DISABLED = b"""
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 22">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#da4453;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none"
       d="M 3 4 L 3 16 L 6 20 L 6 17 L 6 16 L 19 16 L 19 4 L 3 4 z M 4 5 L 18 5 L 18 15 L 4 15 L 4 5 z M 8 6 L 7 7 L 10 10 L 7 13 L 8 14 L 11 11 L 14 14 L 15 13 L 12 10 L 15 7 L 14 6 L 11 9 L 8 6 z "
     class="ColorScheme-Text"
     />
</svg>
"""
ICON_TOOLBAR_ADD_FILTER = b"""
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 22">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path 
     style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 5 3 L 4 4 L 4 5 L 4 5.3046875 L 9 12.367188 L 9 16 L 9 16.039062 L 12.990234 19 L 13 19 L 13 12.367188 L 18 5.3046875 L 18 4 L 17 3 L 5 3 z M 5 4 L 17 4 L 17 4.9882812 L 12.035156 12 L 12 12 L 12 12.048828 L 12 13 L 12 17.019531 L 10 15.535156 L 10 13 L 10 12.048828 L 10 12 L 9.9648438 12 L 5 4.9882812 L 5 4 z M 6 5 L 8 8 L 8 6 L 10 5 L 6 5 z M 16 14 L 16 16 L 14 16 L 14 17 L 16 17 L 16 19 L 17 19 L 17 17 L 19 17 L 19 16 L 17 16 L 17 14 L 16 14 z "
     class="ColorScheme-Text"
     />
</svg>
"""
ICON_TOOLBAR_DEL_FILTER = b"""
<svg id="svg8" version="1.1" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg">
    <defs id="defs3051">
        <style id="current-color-scheme" type="text/css">.ColorScheme-Text {
        color:#232629;
      }</style>
    </defs>
    <path id="path4" class="ColorScheme-Text" d="m5 3-1 1v1.3046875l5 7.0625005v3.671872l3 2.226563v-1.246092l-2-1.484375v-3.535156h-0.035156l-4.964844-7.0117188v-0.9882812h12v0.9882812l-4.964844 7.0117188h1.22461l4.740234-6.6953125v-1.3046875l-1-1zm1 2 2 3v-2l2-1z" fill="currentColor"/>
    <path id="path6" d="M 13.990234,13 13,13.990234 15.009766,16 13,18.009766 13.990234,19 16,16.990234 18.009766,19 19,18.009766 16.990234,16 19,13.990234 18.009766,13 16,15.009766 Z" fill="#da4453"/>
</svg>
"""

TABLE_HEADER_STYLE = "font-weight: bold;font-size: 9pt;"

ABOUT_TEXT = f"""

<b>jouno version {JOUNO_VERSION}</b>
<p>
A journal-entry to desktop-notification forwarder. 
<p>
<i>Right-mouse &rarr; context-menu &rarr; help</i> for help.
<p>
Visit <a href="https://github.com/digitaltrails/jouno">https://github.com/digitaltrails/jouno</a> for 
more details.
<p><p>

<b>jouno Copyright (C) 2021 Michael Hamilton</b>
<p>
This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, version 3.
<p>
This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
more details.
<p>
You should have received a copy of the GNU General Public License along
with this program. If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.

"""

DEFAULT_CONFIG = '''
[options]
poll_seconds = 2
burst_seconds = 5
burst_truncate_messages = 3
notification_seconds = 60
journal_history_max = 100
system_tray_enabled = yes
start_with_notifications_enabled = yes
debug_enabled = no

[ignore] 
kwin_bad_damage = XCB error: 152 (BadDamage)
kwin_bad_window = kwin_core: XCB error: 3 (BadWindow)
self_caused = NotificationPopup.
qt_kde_binding_loop = Binding loop detected for property

[match]

'''


# ######################## MONITOR SUB PROCESS CODE ###############################################################
# TODO The monitor code has been written so it can be extracted to a future non pyqt command line utility.

class Priority(Enum):
    EMERGENCY = 0
    ALERT = 1
    CRITICAL = 2
    ERR = 3
    WARNING = 4
    NOTICE = 5
    INFO = 6
    DEBUG = 7


NOTIFICATION_ICONS = {
    Priority.EMERGENCY: 'dialog-error',
    Priority.ALERT: 'dialog-error',
    Priority.CRITICAL: 'dialog-error',
    Priority.ERR: 'dialog-error',
    Priority.WARNING: 'dialog-warning',
    Priority.NOTICE: 'dialog-information',
    Priority.INFO: 'dialog-information',
    Priority.DEBUG: 'dialog-information',
}

debugging = True


def debug(*arg):
    if debugging:
        print('DEBUG:', *arg)


def info(*arg):
    print('INFO:', *arg)


def warning(*arg):
    print('WARNING:', *arg)


def error(*arg):
    print('ERROR:', *arg)


xml_escape_table = str.maketrans({
    "<": "&lt;",
    ">": "&gt;",
    "&": "&amp;",
    "'": "&apos;",
    '"': "&quot;",
})


def xmlesc(txt: str):
    return txt.translate(xml_escape_table)


class NotifyFreeDesktop:

    def __init__(self):
        self.notify_interface = dbus.Interface(
            object=dbus.SessionBus().get_object("org.freedesktop.Notifications", "/org/freedesktop/Notifications"),
            dbus_interface="org.freedesktop.Notifications")

    def notify_desktop(self, app_name: str, summary: str, message: str, priority: Priority, timeout: int):
        # https://specifications.freedesktop.org/notification-spec/notification-spec-latest.html
        replace_id = 0
        notification_icon = NOTIFICATION_ICONS[priority] + ".png"
        action_requests = []
        # extra_hints = {"urgency": 1, "sound-name": "dialog-warning", }
        extra_hints = {}
        self.notify_interface.Notify(app_name, replace_id, notification_icon, summary, message, action_requests,
                                     extra_hints,
                                     timeout)


def get_config_path() -> Path:
    config_dir_path = Path.home().joinpath('.config').joinpath('jouno')
    if not config_dir_path.parent.is_dir():
        os.makedirs(config_dir_path)
    path = config_dir_path.joinpath('jouno.conf')
    return path


class Config(configparser.ConfigParser):

    def __init__(self):
        super().__init__()
        self.path = get_config_path()
        self.modified_time = 0.0
        self.read_string(DEFAULT_CONFIG)

    def save(self):
        with open(self.path, 'w') as config_file:
            self.write(config_file)

    def refresh(self) -> bool:
        if self.path.is_file():
            modified_time = self.path.lstat().st_mtime
            if self.modified_time == modified_time:
                return False
            self.modified_time = modified_time
            info(f"Reading {self.path}")
            config_text = self.path.read_text()
            for section in ['match', 'ignore']:
                self.remove_section(section)
            self.read_string(config_text)
            for section in ['options', 'match', 'ignore']:
                if section not in self:
                    self[section] = {}
            return True
        if self.modified_time > 0.0:
            info(f"Config file has been deleted: {self.path}")
            self.modified_time = 0.0
        return False


class JournalWatcher:

    def __init__(self, supervisor=None):
        self.config: Config = None
        self.burst_truncate: int = 3
        self.polling_millis: int = 2_000
        self.notification_timeout_millis: int = 60_000
        self.burst_max_millis = 10_000
        self.ignore_regexp: Mapping[str, re] = {}
        self.match_regexp: Mapping[str, re] = {}
        self.update_config()
        self._stop = False
        self.supervisor = supervisor
        self.notifications_enabled = True

    def is_notifying(self) -> bool:
        return self.notifications_enabled

    def enable_notifications(self, enable: bool):
        self.notifications_enabled = enable

    def update_config(self):
        if self.config is None:
            self.config = Config()
        if not self.config.refresh():
            return
        if 'poll_seconds' in self.config['options']:
            self.polling_millis = 1_000 * self.config.getint('options', 'poll_seconds')
        if 'burst_truncate_messages' in self.config['options']:
            self.burst_truncate = self.config.getint('options', 'burst_truncate_messages')
        if 'burst_seconds' in self.config['options']:
            self.burst_max_millis = 1_000 * self.config.getint('options', 'burst_seconds')
        if 'notification_seconds' in self.config['options']:
            self.notification_timeout_millis = 1_000 * self.config.getint('options', 'notification_seconds')
        if 'debug' in self.config['options']:
            global debugging
            debugging = self.config.getboolean('options', 'debug')
            info("Debugging output is disabled.") if not debugging else None
        self.ignore_regexp: Mapping[str, re] = {}
        self.match_regexp: Mapping[str, re] = {}
        self.compile_patterns(self.config['match'], self.match_regexp)
        self.compile_patterns(self.config['ignore'], self.ignore_regexp)

    def compile_patterns(self, rules_map: Mapping[str, str], patterns_map: Mapping[str, re.Pattern]):
        for rule_id, rule_text in rules_map.items():
            if rule_id.endswith('_enabled'):
                pass
            else:
                rule_enabled_key = rule_id + "_enabled"
                if rule_enabled_key not in rules_map or rules_map[rule_enabled_key].lower() == 'yes':
                    if rule_id.endswith('_regexp'):
                        patterns_map[rule_id] = re.compile(rule_text)
                    else:
                        patterns_map[rule_id] = re.compile(re.escape(rule_text))

    def determine_app_name(self, journal_entries: List[Mapping[str, Any]]):
        app_name_info = ''
        sep = '\u25b3'
        for journal_entry in journal_entries:
            for key, prefix in {'_CMDLINE': '', '_EXE': '', '_COMM': '', 'SYSLOG_IDENTIFIER': '',
                                '_KERNEL_SUBSYSTEM': 'kernel ',
                                }.items():
                # debug("determine_app_name", key, journal_entry[key] if key in journal_entry else False) if debugging else None
                if key in journal_entry:
                    value = str(journal_entry[key])
                    if app_name_info.find(value) < 0:
                        app_name_info += sep + prefix + value
                        sep = '; '
        if app_name_info == '':
            app_name_info = sep + 'unknown'
        return app_name_info

    def determine_summary(self, journal_entries: List[Mapping[str, Any]]):
        journal_entry = journal_entries[0]
        realtime = journal_entry['__REALTIME_TIMESTAMP']
        transport = f" {journal_entry['_TRANSPORT']}" if '_TRANSPORT' in journal_entry else ''
        number_of_entries = len(journal_entries)
        if number_of_entries > 1:
            summary = f"\u25F4{realtime:%H:%M:%S}:{transport} Burst of {number_of_entries} messages"
        else:
            text = ''
            sep = ''
            for key, prefix in {'SYSLOG_IDENTIFIER': '', '_PID': 'PID ', '_KERNEL_SUBSYSTEM': 'kernel ', }.items():
                if key in journal_entry:
                    value = str(journal_entry[key])
                    if text.find(value) < 0:
                        text += sep + prefix + value
                        sep = ' '
            summary = f"\u25F4{realtime:%H:%M:%S}: {text} (\u21e8{transport})"
        # debug(f"realtime='{realtime}' summary='{summary}'") if debugging else None
        return summary

    def determine_message(self, journal_entries: List[Mapping[str, Any]]) -> str:
        message = ''
        sep = ''
        previous_message = ''
        duplicates = 0
        reported = 0
        for journal_entry in journal_entries:
            new_message = journal_entry['MESSAGE']
            if new_message == previous_message:
                duplicates += 1
            else:
                message += f"{sep}\u25B7{new_message}"
                previous_message = new_message
                reported += 1
                if reported == self.burst_truncate and reported < len(journal_entries):
                    message += f"\n[Only showing first {self.burst_truncate} messages]"
                    break
            sep = '\n'
        if duplicates > 0:
            message += f'\n[{duplicates + 1} duplicate messages]'
        # debug(f'message={message}') if debugging else None
        return message

    def determine_priority(self, journal_entries: List[Mapping[str, Any]]) -> Priority:
        current_level = Priority.NOTICE
        for journal_entry in journal_entries:
            if 'PRIORITY' in journal_entry:
                priority = journal_entry['PRIORITY']
                if priority < current_level.value and (Priority.EMERGENCY.value <= priority <= Priority.DEBUG.value):
                    current_level = Priority(priority)
        return current_level

    def is_notable(self, journal_entry: Mapping[str, Any]):
        # Is a list comprehension slower than a for-loop for string construction?
        # Use an easy a format that is easy to pattern match
        fields_str = ', '.join((f"'{key}={str(value)}'" for key, value in journal_entry.items()))
        # debug(fields_str) if debugging else None
        for rule_id, match_re in self.match_regexp.items():
            if match_re.search(fields_str) is not None:
                # debug(f"rule=match.{rule_id}: {journal_entry['MESSAGE']}") if debugging else None
                return True
        for rule_id, ignore_re in self.ignore_regexp.items():
            if ignore_re.search(fields_str) is not None:
                # debug(f"rule=ignore.{rule_id}: {journal_entry['MESSAGE']}") if debugging else None
                return False
        # otherwise no patterns matched:
        # 1) if there are any 'match' patterns at all, we need to return False.
        # 2) if there are no 'match' patterns at all, we need to return True.
        return len(self.match_regexp) == 0

    def is_stop_requested(self) -> bool:
        return self.supervisor.isInterruptionRequested()

    def watch_journal(self):
        self._stop = False
        notify = NotifyFreeDesktop()

        journal_reader = journal.Reader()
        journal_reader.seek_tail()
        journal_reader.get_previous()

        journal_reader_poll = select.poll()
        journal_reader_poll.register(journal_reader, journal_reader.get_events())
        journal_reader.add_match()
        while True:
            if self.is_stop_requested():
                return
            self.update_config()
            burst_count = 0
            notable = []
            limit_time_ns = self.burst_max_millis * 1_000_000 + time.time_ns()
            while journal_reader_poll.poll(self.polling_millis) and time.time_ns() < limit_time_ns:
                if self.is_stop_requested():
                    return
                if journal_reader.process() == journal.APPEND:
                    for journal_entry in journal_reader:
                        if self.is_stop_requested():
                            return
                        burst_count += 1
                        if self.is_notable(journal_entry):
                            # debug(f"Notable: burst_count={len(notable)}: {journal_entry['MESSAGE']}") if debugging else None
                            notable.append(journal_entry)
                            self.supervisor.new_journal_entry(journal_entry)
            if self.notifications_enabled and len(notable):
                notify.notify_desktop(app_name=self.determine_app_name(notable),
                                      summary=self.determine_summary(notable),
                                      message=self.determine_message(notable),
                                      priority=self.determine_priority(notable),
                                      timeout=self.notification_timeout_millis)


def tr(source_text: str):
    """For future internationalization - recommended way to do this at this time."""
    return QCoreApplication.translate('jouno', source_text)


# ######################## USER INTERFACE CODE ######################################################################

def is_dark_theme():
    # Heuristic for checking for a dark theme.
    # Is the sample text lighter than the background?
    label = QLabel("am I in the dark?")
    text_hsv_value = label.palette().color(QPalette.WindowText).value()
    bg_hsv_value = label.palette().color(QPalette.Background).value()
    dark_theme_found = text_hsv_value > bg_hsv_value
    # debug(f"is_dark_them text={text_hsv_value} bg={bg_hsv_value} is_dark={dark_theme_found}") if debugging else None
    return dark_theme_found


def create_image_from_svg_bytes(svg_str: bytes) -> QImage:
    """There is no QIcon option for loading QImage from a string, only from a SVG file, so roll our own."""
    if is_dark_theme():
        svg_str = svg_str.replace(ICON_BLACK_COLOR, ICON_WHITE_COLOR)
    renderer = QSvgRenderer(svg_str)
    image = QImage(64, 64, QImage.Format_ARGB32)
    image.fill(0x0)
    painter = QPainter(image)
    renderer.render(painter)
    painter.end()
    return image


def create_pixmap_from_svg_bytes(svg_str: bytes) -> QPixmap:
    """There is no QIcon option for loading SVG from a string, only from a SVG file, so roll our own."""
    image = create_image_from_svg_bytes(svg_str)
    return QPixmap.fromImage(image)


def create_icon_from_svg_bytes(default_svg: bytes = None,
                               on_svg: bytes = None, off_svg: bytes = None,
                               disabled_svg: bytes = None) -> QIcon:
    """There is no QIcon option for loading SVG from a string, only from a SVG file, so roll our own."""
    if default_svg is not None:
        icon = QIcon(create_pixmap_from_svg_bytes(default_svg))
    else:
        icon = QIcon()
    if on_svg is not None:
        icon.addPixmap(create_pixmap_from_svg_bytes(on_svg), state=QIcon.On)
    if off_svg is not None:
        icon.addPixmap(create_pixmap_from_svg_bytes(off_svg), state=QIcon.Off)
    if disabled_svg:
        icon = QIcon(create_pixmap_from_svg_bytes(on_svg), mode=QIcon.Disabled)
    return icon


def get_icon(source) -> QIcon:
    # Consider caching icon loading - but icons are mutable and subject to theme changes,
    # so perhaps that's asking for trouble.
    if isinstance(source, str):
        return QIcon.fromTheme(source)
    if isinstance(source, bytes):
        return create_icon_from_svg_bytes(source)
    raise ValueError(f"get_icon parameter has unsupported type {type(source)} = {str(source)}")


def big_label(widget: QLabel) -> QLabel:
    # Setting the style breaks theme changes, use HTML instead
    # widget.setStyleSheet("QLabel { font-weight: normal;font-size: 12pt; }")
    widget.setTextFormat(Qt.TextFormat.AutoText)
    widget.setText(f"<b>{widget.text()}</b>")
    return widget


def transparent_button(button: QPushButton) -> QPushButton:
    button.setStyleSheet("""
        QPushButton { background-color: transparent; border: 0px; width:32px; height:32px; }
        QPushButton:hover { border: 1px solid blue; }
        """)
    button.setIconSize(QSize(24, 24))
    return button


class OptionsTab(QWidget):

    def __init__(self, config_section: Mapping[str, str], parent: QWidget = None):
        super().__init__(parent=parent)
        self.option_map: Mapping[str, QWidget] = {}
        layout = QGridLayout(self)
        row_number = 0
        for option_id, value in config_section.items():
            label_widget = QLabel(tr(option_id))
            if option_id.endswith("_enabled"):
                input_widget = QCheckBox()
                input_widget.setChecked(value == 'yes')
            else:
                input_widget = QLineEdit()
                if '_seconds' in option_id:
                    max_value = 120
                elif '_history' in option_id:
                    max_value = 1000
                else:
                    max_value = 20
                input_widget.setValidator(QIntValidator(0, max_value))
                input_widget.setMaximumWidth(100)
                input_widget.setText(value)
            layout.addWidget(label_widget, row_number, 0)
            layout.addWidget(input_widget, row_number, 1, 1, 2, alignment=Qt.AlignLeft)
            self.option_map[option_id] = input_widget
            row_number += 1
        # Add a spacer to force those above to scrunch up.
        layout.addWidget(QWidget(), row_number, 1, 2, 2, alignment=Qt.AlignLeft)
        self.setLayout(layout)

    def copy_from_config(self, config_section: Mapping[str, str]):
        for option_id, widget in self.option_map.items():
            if option_id in config_section:
                if option_id.endswith("_enabled"):
                    widget.setChecked(config_section[option_id].lower() == "yes")
                else:
                    widget.setText(config_section[option_id])

    def copy_to_config(self, config_section: Mapping[str, str]):
        for option_id, widget in self.option_map.items():
            if option_id.endswith("_enabled"):
                config_section[option_id] = "yes" if widget.isChecked() else "no"
            else:
                if widget.text().strip() != "":
                    config_section[option_id] = widget.text()


class FilterPanel(QWidget):

    def __init__(self, config_section: Mapping[str, str], tooltip: str = 'tip', parent: QWidget = None):
        super().__init__(parent=parent)
        debug("table", str(config_section.keys())) if debugging else None

        self.table_view = FilterTableView(config_section, tooltip)

        # TODO add a test rules button that pops up a testing dialog with an input field.
        layout = QVBoxLayout(self)
        layout.addWidget(self.table_view)
        self.setLayout(layout)

    def is_valid(self):
        return self.table_view.is_valid()

    def copy_from_config(self, config_section: Mapping[str, str]):
        self.table_view.copy_from_config(config_section)

    def copy_to_config(self, config_section: Mapping[str, str]):
        self.table_view.copy_to_config(config_section)

    def clear_selection(self):
        self.table_view.clearSelection()

    def add_rule(self, rule_id: str = '', pattern: str = ''):
        self.table_view.add_new_rule(rule_id, pattern)

    def delete_rules(self):
        self.table_view.delete_selected_rules()


class FilterTableModel(QStandardItemModel):

    def __init__(self, number_of_rows: int):
        super().__init__(number_of_rows, 2)
        # use spaces to force a wider column - seems to be no other EASY way to do this.
        self.setHorizontalHeaderLabels(
            [tr("Rule-ID (enabled/disabled)"), tr("Pattern")])


class FilterValidationException(Exception):
    pass


class FilterTableView(QTableView):

    def __init__(self, config_section: Mapping[str, str], tooltip=""):
        super().__init__()
        self.enable_tooltip = \
            tr("Enable: rules can be selective enabled/disabled.")
        self.rule_id_tooltip_1 = \
            tr("Rule ID: a letter followed by letters, digits, underscores and hyphens")
        self.rule_id_tooltip_2 = \
            tr("A rule ID with a _regexp suffix denotes its pattern to be a regular expression.")
        self.pattern_tooltip = \
            tr("Pattern: Text or regexp to partially match in the journal entry's message field.")
        tooltip += "\n\n" + tr("Columns:") + "\n" + \
                   tr(f"    {self.enable_tooltip}\n") + \
                   tr(f"    {self.rule_id_tooltip_1}\n") + \
                   tr(f"          {self.rule_id_tooltip_2}\n") + \
                   tr(f"    {self.pattern_tooltip}\n")
        self.setToolTip(tooltip)
        self.setModel(FilterTableModel(len(config_section)))
        self.copy_from_config(config_section)
        self.setEditTriggers(QAbstractItemView.AllEditTriggers)
        self.verticalHeader().setSectionsMovable(True)
        self.verticalHeader().setDragEnabled(True)
        self.verticalHeader().setDragDropMode(QAbstractItemView.InternalMove)
        self.setDragDropOverwriteMode(True)
        self.resizeColumnsToContents()
        self.setSelectionMode(QAbstractItemView.SingleSelection)
        self.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.horizontalHeader().setSectionResizeMode(1, QHeaderView.Stretch)
        self.horizontalHeader().setDefaultAlignment(Qt.AlignLeft)
        self.setShowGrid(False)

    def item_view_order(self) -> List[int]:
        """
        Walk the table model's rows in model-order of 1..n, find the current y-location or each row,
        sort the y-locations to determine the current view ordering of the model's rows (which may
        no longer be 1..n due to drag and drop).  Return a list of the current view ordering, for
        example [4, 0, 1, 2, 3].
        """
        # If there is no access to the rowCount, rowViewportPosition() can be called
        # until it returns -1 (note it can return other valid negative values, so just test
        # for -1.
        row_y_positions = []
        debug(f"row count={self.model().rowCount()}") if debugging else None
        for row_num in range(self.model().rowCount()):
            y = self.rowViewportPosition(row_num)
            row_y_positions.append((y, row_num))
        row_y_positions.sort()
        return [row_num for _, row_num in row_y_positions]

    def create_rule_id_item(self, rule_id: str):
        enable_item = QStandardItem(rule_id)
        enable_item.setCheckable(True)
        enable_item.setCheckState(Qt.Checked)
        enable_item.setEditable(True)
        enable_item.setToolTip(tr(self.rule_id_tooltip_1 + "\n" + self.rule_id_tooltip_2))
        return enable_item

    def is_valid(self) -> bool:
        model = self.model()
        seen = []
        for row_num in self.item_view_order():
            key = model.item(row_num, 0).text()
            value = model.item(row_num, 1).text()
            if re.fullmatch("[a-zA-Z]([a-zA-Z0-9_-])*", key) is None:
                raise FilterValidationException(
                    self.__class__.__name__, "Invalid Rule-ID", f"ID='{key}'")
            elif key in seen:
                raise FilterValidationException(
                    self.__class__.__name__, "Duplicate Rule-ID", f"ID='{key}'")
            elif key.endswith("_regexp"):
                try:
                    re.compile(value)
                except Exception as e:
                    raise FilterValidationException(
                        self.__class__.__name__, "Invalid Regular Expression", f"\n{key}={value}\n\n{str(e)}")
            seen.append(key)
        return True

    def copy_from_config(self, config_section: Mapping[str, str]):
        model = self.model()
        if model.rowCount() > 0:
            model.removeRows(0, model.rowCount())
        row = 0
        # Step one - first gather the patterns and create a row for each one
        for key, value in config_section.items():
            if key.endswith("_enabled"):
                pass
            else:
                key_item = self.create_rule_id_item(key)
                key_enabled = key + "_enabled"
                if key_enabled in config_section:
                    if config_section[key_enabled].strip().lower() != 'yes':
                        key_item.setCheckState(Qt.Unchecked)
                model.setItem(row, 0, key_item)
                value_item = QStandardItem(value)
                value_item.setToolTip(self.pattern_tooltip)
                model.setItem(row, 1, QStandardItem(value_item))
                row += 1

    def copy_to_config(self, config_section: Mapping[str, str]):
        debug(f'table order = {self.item_view_order()} ') if debugging else None
        for key in config_section.keys():
            del config_section[key]
        model = self.model()
        for row_num in self.item_view_order():
            key = model.item(row_num, 0).text()
            if key.strip() == '':
                continue
            value = model.item(row_num, 1).text()
            config_section[key] = value
            if model.item(row_num, 0).checkState() == Qt.Unchecked:
                config_section[key + "_enabled"] = "no"

    select_flags = QItemSelectionModel.Clear | QItemSelectionModel.Rows | QItemSelectionModel.SelectCurrent | QItemSelectionModel.Rows

    def add_new_rule(self, rule_id: str = '', pattern: str = ''):
        model = self.model()
        selected_row_indices = self.selectionModel().selectedRows()
        if len(selected_row_indices) > 0:
            index = sorted(selected_row_indices)[0]
            model.insertRow(index.row(), [self.create_rule_id_item(rule_id), QStandardItem(pattern)])
            self.scrollTo(index)
            self.clearSelection()
            self.selectRow(index.row())
        else:
            model.appendRow([self.create_rule_id_item(rule_id), QStandardItem(pattern)])
            self.scrollToBottom()
            self.selectRow(model.rowCount() - 1)

    def delete_selected_rules(self):
        model = self.model()
        selected_row_indices = self.selectionModel().selectedRows()
        if len(selected_row_indices) == 0:
            message = QMessageBox(self)
            message.setWindowTitle(tr('Delete'))
            message.setText(
                tr("Cannot delete, no rows selected.\nClick in the left margin to select some rows."))
            message.setIcon(QMessageBox.Critical)
            message.setStandardButtons(QMessageBox.Ok)
            message.exec()
            return
        # Reverse the order so we delete from bottom up preserving the positions of yet to be removed rows.
        for index in sorted(selected_row_indices, reverse=True):
            model.removeRow(index.row())
            if model.rowCount() > index.row():
                self.selectRow(model.rowCount())
            else:
                self.selectRow(model.rowCount() - 1)


class ConfigWatcherTask(QThread):
    signal_config_change = pyqtSignal()

    def __init__(self, config: Config) -> None:
        super().__init__()
        self.config = config

    def run(self) -> None:
        while True:
            if self.config.refresh():
                debug("ConfigWatcherTask - Config Changed") if debugging else None
                self.signal_config_change.emit()
            time.sleep(5.0)


class JournalWatcherTask(QThread):
    signal_new_entry = pyqtSignal(dict)

    def __init__(self) -> None:
        super().__init__()
        self.watcher = JournalWatcher(self)

    def is_notifying(self) -> bool:
        return self.watcher.is_notifying()

    def enable_notifications(self, enable: bool):
        self.watcher.enable_notifications(enable)

    def run(self) -> None:
        self.watcher.watch_journal()

    def new_journal_entry(self, journal_entry: Mapping):
        self.signal_new_entry.emit(journal_entry)


class ConfigPanel(QWidget):

    def __init__(self, tab_change: Callable, config_change_func: Callable, parent: QWidget):
        super().__init__(parent=parent)
        self.setObjectName('config_panel')
        layout = QVBoxLayout()
        self.setLayout(layout)
        tabs = QTabWidget()
        self.tabs = tabs

        self.config = Config()
        self.config.refresh()

        options_panel = OptionsTab(self.config['options'], parent=self)

        match_panel = FilterPanel(
            self.config['match'],
            tooltip=tr("Only issue notifications for journal-entry messages that match one of these rules."),
            parent=parent)

        ignore_panel = FilterPanel(
            self.config['ignore'],
            tooltip=tr("Ignore journal-entry messages that match any of these rules."),
            parent=parent)

        button_box = QWidget()
        button_box_layout = QGridLayout()
        button_box.setLayout(button_box_layout)
        apply_button = QPushButton(tr("Apply"))
        revert_button = QPushButton(tr("Revert"))

        button_box_layout.addWidget(apply_button, 0, 0)
        button_box_layout.addWidget(revert_button, 0, 1)
        button_box_layout.setColumnMinimumWidth(3, 200)

        def save_action():
            debug("save action") if debugging else None
            try:
                if match_panel.is_valid() and ignore_panel.is_valid():
                    options_panel.copy_to_config(self.config['options'])
                    match_panel.copy_to_config(self.config['match'])
                    ignore_panel.copy_to_config(self.config['ignore'])
                    self.config.save()
                    match_panel.clear_selection()
                    ignore_panel.clear_selection()
                    message = QMessageBox(self)
                    message.setWindowTitle(tr('Applied'))
                    message.setText(tr('Changes are now active.'))
                    message.setIcon(QMessageBox.Information)
                    message.setStandardButtons(QMessageBox.Ok)
                    # message.setDetailedText()
                    message.exec()
                    debug(f'config saved ok') if debugging else None
            except FilterValidationException as e:
                e_title, summary, text = e.args
                message = QMessageBox(self)
                message.setWindowTitle(e_title)
                message.setText(f"{tr('Cannot apply changes.')}\n{summary}\n{text}")
                message.setIcon(QMessageBox.Critical)
                message.setStandardButtons(QMessageBox.Ok)
                # message.setDetailedText()
                message.exec()

        apply_button.clicked.connect(save_action)

        def revert_action():
            debug("revert") if debugging else None
            before = pickle.dumps(self.config)
            tmp = pickle.loads(before)
            options_panel.copy_to_config(tmp['options'])
            match_panel.copy_to_config(tmp['match'])
            ignore_panel.copy_to_config(tmp['ignore'])
            after = pickle.dumps(tmp)
            if before == after:
                revert_message = QMessageBox(self)
                revert_message.setText(tr('There are no unapplied changes, there is nothing to revert.'))
                revert_message.setIcon(QMessageBox.Warning)
                revert_message.setStandardButtons(QMessageBox.Ok)
                revert_message.exec()
                return
            else:
                revert_message = QMessageBox(self)
                revert_message.setText(tr('There are unapplied changes, revert and loose all changes?'))
                revert_message.setIcon(QMessageBox.Question)
                revert_message.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
                if revert_message.exec() == QMessageBox.Cancel:
                    return
            info("reverting unsaved edits")
            reload_from_config()

        def reload_from_config():
            debug("GUI reloading config") if debugging else None
            options_panel.copy_from_config(self.config['options'])
            match_panel.copy_from_config(self.config['match'])
            ignore_panel.copy_from_config(self.config['ignore'])
            match_panel.clear_selection()
            ignore_panel.clear_selection()

        revert_button.clicked.connect(revert_action)

        tabs.addTab(ignore_panel, tr("Ignore Filters"))
        tabs.addTab(match_panel, tr("Match Filters"))
        tabs.addTab(options_panel, tr("Options"))
        tabs.setCurrentIndex(0)

        layout.addWidget(big_label(QLabel("Configuration")))
        layout.addWidget(tabs)
        layout.addWidget(button_box)

        self.setMinimumHeight(280)

        tabs.currentChanged.connect(tab_change)

        reload_from_config()
        self.config_watcher = ConfigWatcherTask(self.config)

        def config_change():
            reload_from_config()
            config_change_func()

        self.config_watcher.signal_config_change.connect(config_change)
        self.config_watcher.start()

    def add_filter(self, rule_id, pattern) -> None:
        if isinstance(self.tabs.currentWidget(), FilterPanel):
            self.tabs.currentWidget().add_rule(rule_id, pattern)
        else:
            raise TypeError("Was expecting FilterPanel")

    def delete_filter(self) -> None:
        if isinstance(self.tabs.currentWidget(), FilterPanel):
            self.tabs.currentWidget().delete_rules()
        else:
            raise TypeError("Was expecting FilterPanel")

    def get_config(self) -> Config:
        return self.config


class MainToolBar(QToolBar):

    def __init__(self,
                 run_func: Callable, notify_func: Callable,
                 add_func: Callable, del_func: Callable,
                 parent: QMainWindow):
        super().__init__(parent=parent)
        self.setObjectName("main-tool-bar")
        # main_tool_bar.setFixedHeight(80)
        self.setIconSize(QSize(32, 32))
        self.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)

        self.icon_run_enabled = get_icon(ICON_TOOLBAR_RUN_ENABLED)
        self.icon_run_disabled = get_icon(ICON_TOOLBAR_RUN_DISABLED)
        self.icon_notifier_enabled = get_icon(ICON_TOOLBAR_NOTIFIER_ENABLED)
        self.icon_notifier_disabled = get_icon(ICON_TOOLBAR_NOTIFIER_DISABLED)
        self.icon_run_stop = get_icon(ICON_TOOLBAR_STOP)
        self.icon_add_filter = get_icon(ICON_TOOLBAR_ADD_FILTER)
        self.icon_del_filter = get_icon(ICON_TOOLBAR_DEL_FILTER)

        self.run_action = self.addAction(self.icon_run_enabled, tr("Run"), run_func)
        self.run_action.setObjectName("run_button")
        self.run_action.setToolTip(tr("Start/stop monitoring the journal feed."))
        # self.widgetForAction(self.run_action).setStyleSheet("QToolButton { width: 130px; }")

        self.stop_action = self.addAction(self.icon_run_stop, tr("Stop"), run_func)
        self.stop_action.setToolTip(tr("Stop monitoring the journal feed."))

        self.addSeparator()

        self.notifier_action = self.addAction(self.icon_notifier_enabled, "notify", notify_func)
        self.notifier_action.setToolTip(tr("Enable/disable desktop notifications."))
        # self.widgetForAction(self.notifier_action).setStyleSheet("QToolButton { width: 130px; }")

        self.addSeparator()

        self.add_filter_action = self.addAction(self.icon_add_filter, "add", add_func)
        self.add_filter_action.setObjectName("add_button")
        self.add_filter_action.setIconText(tr("New filter"))
        self.add_filter_action.setToolTip(
            tr("Add a new filter above the selected filter or at the end if no filter is selected.") + "\n" +
            tr("Select a filter tab and optionally click in its left margin to select an insertion point."))

        self.del_filter_action = self.addAction(self.icon_del_filter, "del", del_func)
        self.del_filter_action.setObjectName("del_button")
        self.del_filter_action.setIconText(tr("Delete filter"))
        self.del_filter_action.setToolTip(
            tr("Delete selected filter.") + "\n" +
            tr("Select a filter tab and click in its left margin to select a filter to delete."))

        spacer = QWidget()
        spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.addWidget(spacer)
        self.addAction(get_icon(ICON_HELP_CONTENTS), tr('Help'), HelpDialog.invoke)
        self.addAction(get_icon(ICON_HELP_ABOUT), tr('About'), AboutDialog.invoke)
        self.installEventFilter(self)
        # parent.toolButtonStyleChanged.connect(style_changed)

    def reload_icons(self):
        self.icon_run_enabled = get_icon(ICON_TOOLBAR_RUN_ENABLED)
        self.icon_run_disabled = get_icon(ICON_TOOLBAR_RUN_DISABLED)
        self.icon_notifier_enabled = get_icon(ICON_TOOLBAR_NOTIFIER_ENABLED)
        self.icon_notifier_disabled = get_icon(ICON_TOOLBAR_NOTIFIER_DISABLED)
        self.icon_run_stop = get_icon(ICON_TOOLBAR_STOP)
        self.icon_add_filter = get_icon(ICON_TOOLBAR_ADD_FILTER)
        self.icon_del_filter = get_icon(ICON_TOOLBAR_DEL_FILTER)

    def eventFilter(self, target: 'QObject', event: 'QEvent') -> bool:
        super().eventFilter(target, event)
        # PalletChange happens after the new style sheet is in use.
        if event.type() == QEvent.PaletteChange:
            debug(f"PaletteChange is_dark_theme()={is_dark_theme()} {str(target)}") if debugging else None
            self.reload_icons()
            self.stop_action.setIcon(self.icon_run_stop)
            self.add_filter_action.setIcon(self.icon_add_filter)
            self.del_filter_action.setIcon(self.icon_del_filter)
        event.accept()
        return True

    def configure_run_action(self, running: bool) -> None:
        debug("Run Style is dark", is_dark_theme()) if debugging else None
        if running:
            self.run_action.setIcon(self.icon_run_enabled)
            self.run_action.setIconText(tr("Running"))
            self.stop_action.setEnabled(True)
        else:
            self.run_action.setIcon(self.icon_run_disabled)
            self.run_action.setIconText(tr("Stopped"))
            self.stop_action.setEnabled(False)

    def configure_notifier_action(self, notifying: bool) -> None:
        padded = pad_text([tr('Notifying'), tr('Mute')])
        if notifying:
            self.notifier_action.setIcon(self.icon_notifier_enabled)
            # self.notifier_action.setIconText(tr("Notifying"))
            self.notifier_action.setIconText(padded[0])
        else:
            self.notifier_action.setIcon(self.icon_notifier_disabled)
            # Don't do this with a style sheet - style sheets will break dark/light theme loading.
            # self.notifier_action.setIconText(tr("Mute   \u2002"))
            self.notifier_action.setIconText(padded[1])

    def configure_filter_actions(self, enable: bool) -> None:
        self.add_filter_action.setEnabled(enable)
        self.del_filter_action.setEnabled(enable)


def pad_text(text_list: List[str]):
    max_width = 0
    width_list = []
    output_list = []
    for text in text_list:
        tmp = QLabel(text)
        tmp.adjustSize()
        width = tmp.fontMetrics().boundingRect(tmp.text()).width()
        if width > max_width:
            #debug(f"text='{text}' New max='{width}'")
            max_width = width
        width_list.append(width)
    for text, width in zip(text_list, width_list):
        if width < max_width:
            space = '\u2002'
            while True:
                spaced = text + space
                tmp2 = QLabel(spaced)
                spaced_width = tmp2.fontMetrics().boundingRect(tmp2.text()).width()
                if spaced_width > max_width:
                    break
                #debug(f"text='{text}' w={spaced_width} max={max_width}")
                text = spaced
        output_list.append(text)
    return output_list


class MainContextMenu(QMenu):

    def __init__(self, run_func: Callable, notify_func: Callable, quit_func: Callable, parent: QWidget):
        super().__init__(parent=parent)
        self.icon_notifier_enabled = get_icon(ICON_TOOLBAR_NOTIFIER_ENABLED)
        self.icon_notifier_disabled = get_icon(ICON_TOOLBAR_NOTIFIER_DISABLED)
        self.listen_action = self.addAction(get_icon(ICON_CONTEXT_MENU_LISTENING_DISABLE),
                                            tr("Stop journal monitoring"),
                                            run_func)
        self.notifier_action = self.addAction(self.icon_notifier_disabled,
                                              tr("Disable notifications"),
                                              notify_func)
        self.addAction(get_icon(ICON_HELP_ABOUT),
                       tr('About'),
                       AboutDialog.invoke)
        self.addAction(get_icon(ICON_HELP_CONTENTS),
                       tr('Help'),
                       HelpDialog.invoke)
        self.addSeparator()
        self.addAction(get_icon(ICON_APPLICATION_EXIT),
                       tr('Quit'),
                       quit_func)

    def configure_run_action(self, running: bool) -> None:
        if running:
            self.listen_action.setText(tr("Stop journal monitoring"))
            self.listen_action.setIcon(get_icon(ICON_CONTEXT_MENU_LISTENING_DISABLE))
        else:
            self.listen_action.setText(tr("Resume journal monitoring"))
            self.listen_action.setIcon(get_icon(ICON_CONTEXT_MENU_LISTENING_ENABLE))

    def configure_notifier_action(self, notifying: bool) -> None:
        if notifying:
            self.notifier_action.setText(tr("Disable notifications"))
            self.notifier_action.setIcon(self.icon_notifier_disabled)
        else:
            self.notifier_action.setText(tr("Enable notifications"))
            self.notifier_action.setIcon(self.icon_notifier_enabled)


class MainWindow(QMainWindow):
    signal_theme_change = pyqtSignal()

    def __init__(self, app: QApplication):
        super().__init__()

        global debugging
        self.setObjectName('main_window')

        journal_watcher_task = JournalWatcherTask()
        debug('QStyleFactory.keys()=', QStyleFactory.keys())
        info(f"Icon theme path={QIcon.themeSearchPaths()}")
        info(f"Icon theme '{QIcon.themeName()}' >> is_dark_theme()={is_dark_theme()}")

        app_name = tr('Jouno')
        app.setWindowIcon(get_icon(ICON_JOUNO_LIGHT))
        app.setApplicationDisplayName(app_name)
        app.setApplicationVersion(JOUNO_VERSION)

        self.settings = QSettings('jouno.qt.state', 'jouno')

        def update_title_and_tray_indicators() -> None:
            if journal_watcher_task.isRunning():
                title_text = tr("Running") if journal_watcher_task.is_notifying() else tr("Muted")
                self.setWindowTitle(title_text)
                tray.setToolTip(f"{title_text} \u2014 {app_name}")
                tray.setIcon(get_icon(ICON_JOUNO))
            else:
                self.setWindowTitle(tr("Stopped"))
                tray.setToolTip(f"{tr('Stopped')} \u2014 {app_name}")
                tray.setIcon(get_icon(ICON_TRAY_LISTENING_DISABLED))

        def enable_listener(enable: bool) -> None:
            if enable:
                journal_watcher_task.start()
                while not journal_watcher_task.isRunning():
                    time.sleep(0.2)
            else:
                journal_watcher_task.requestInterruption()
                while journal_watcher_task.isRunning():
                    time.sleep(0.2)

            tool_bar.configure_run_action(enable)
            app_context_menu.configure_run_action(enable)
            update_title_and_tray_indicators()

        def toggle_listener() -> None:
            enable_listener(not journal_watcher_task.isRunning())

        def enable_notifier(enable: bool) -> None:
            journal_watcher_task.enable_notifications(enable)
            tool_bar.configure_notifier_action(enable)
            app_context_menu.configure_notifier_action(enable)
            update_title_and_tray_indicators()

        def toggle_notifier() -> None:
            enable_notifier(not journal_watcher_task.is_notifying())

        def quit_app() -> None:
            journal_watcher_task.requestInterruption()
            self.app_save_state()
            app.quit()

        def tab_change(tab_number) -> None:
            tool_bar.configure_filter_actions(tab_number == 0 or tab_number == 1)

        def config_change() -> None:
            journal_panel.set_max_journal_entries(config_panel.get_config().getint('options', 'journal_history_max'))
            global debugging
            debugging = config_panel.get_config().getboolean('options', 'debug_enabled')
            if config_panel.get_config().getboolean('options', 'system_tray_enabled'):
                if not tray.isVisible():
                    tray.setVisible(True)
            else:
                if tray.isVisible():
                    tray.setVisible(False)

        def add_filter() -> None:
            journal_entry = journal_panel.get_selected_journal_entry()
            config_panel.add_filter('<new_id>', '' if journal_entry is None else journal_entry['MESSAGE'])

        def delete_filter() -> None:
            config_panel.delete_filter()

        self.config_panel = config_panel = ConfigPanel(tab_change=tab_change, config_change_func=config_change, parent=self)

        debugging = config_panel.get_config().getboolean('options', 'debug_enabled')

        self.journal_window = JournalMainWindow(app_main_window=self)

        self.journal_panel = journal_panel = JournalPanel(
            journal_watcher_task=journal_watcher_task,
            max_journal_entries=config_panel.get_config().getint('options', 'journal_history_max'),
            app_main_window=self, journal_main_window=self.journal_window)

        self.setCentralWidget(config_panel)

        tool_bar = MainToolBar(
            run_func=toggle_listener, notify_func=toggle_notifier,
            add_func=add_filter, del_func=delete_filter,
            parent=self)
        self.addToolBar(tool_bar)

        app_context_menu = MainContextMenu(
            run_func=toggle_listener, notify_func=toggle_notifier, quit_func=quit_app, parent=self)

        tray = QSystemTrayIcon()
        tray.setIcon(get_icon(ICON_JOUNO))
        tray.setContextMenu(app_context_menu)
        self.signal_theme_change.connect(update_title_and_tray_indicators)

        tray.activated.connect(self.tray_activate_window)
        if config_panel.get_config().getboolean('options', 'system_tray_enabled'):
            tray.setVisible(True)
        else:
            self.show()

        enable_listener(True)
        enable_notifier(config_panel.get_config().getboolean('options', 'start_with_notifications_enabled'))

        if len(self.settings.allKeys()) == 0:
            # First run or qt settings have been erased - guess at sizes and locations
            rec = QApplication.desktop().screenGeometry()
            x = int(rec.width())
            y = int(rec.height())
            self.setGeometry(x//2 - 100, y//3, x//3, y//2)
            self.journal_window.setGeometry(x//2 - 150 - x//3, y // 3, x // 3, y // 2)
        self.app_restore_state()

        rc = app.exec_()
        if rc == 999:  # EXIT_CODE_FOR_RESTART:
            QProcess.startDetached(app.arguments()[0], app.arguments()[1:])

    def event(self, event: 'QEvent') -> bool:
        super().event(event)
        # ApplicationPaletteChange happens after the new style theme is in use.
        if event.type() == QEvent.ApplicationPaletteChange:
            debug(f"ApplicationPaletteChange is_dark_theme() {is_dark_theme()}") if debugging else None
            self.signal_theme_change.emit()
        return True

    def closeEvent(self, event: QCloseEvent) -> None:
        info("closeEvent")
        if self.config_panel.get_config().getboolean('options', 'system_tray_enabled'):
            self.tray_activate_window()
        else:
            self.app_save_state()
        super().closeEvent(event)

    def tray_activate_window(self):
        if self.isVisible():
            debug("tray_activate_window hide")
            self.hide()
            if not self.journal_panel.is_docked_to_main:
                debug("Hide journal window too")
                self.journal_window.hide()
        else:
            debug("tray_activate_window show")
            self.show()
            # Attempt to force it to the top with raise and activate
            self.raise_()
            self.activateWindow()
            if not self.journal_panel.is_docked_to_main:
                self.journal_window.show()
                self.journal_window.raise_()
                self.journal_window.activateWindow()

    def app_save_state(self):
        for widget in [self.journal_window, self.journal_panel, self.config_panel, self]:
            geometry_key = 'geometry_' + widget.objectName()
            state_key = 'window_state_' + widget.objectName()
            debug(f"Saving {geometry_key} {self.config_panel.height()}")
            self.settings.setValue(geometry_key, widget.saveGeometry())
            if isinstance(widget, QMainWindow):
                debug(f"Saving {state_key}")
                self.settings.setValue(state_key, widget.saveState())
        self.settings.setValue('journal_panel_in_main_dock', b'yes' if self.journal_panel.is_docked_to_main else b'no')

    def app_restore_state(self):
        dock_val = self.settings.value('journal_panel_in_main_dock', b'yes')
        debug("journal_panel_in_main_dock=", dock_val)
        for widget in [self.config_panel, self.journal_panel, self.journal_window, self]:
            geometry_key = 'geometry_' + widget.objectName()
            state_key = 'window_state_' + widget.objectName()
            geometry = self.settings.value(geometry_key, None)
            if geometry is not None:
                debug(f"Restoring {geometry_key}")
                widget.restoreGeometry(geometry)
            if isinstance(widget, QMainWindow):
                window_state = self.settings.value(state_key, None)
                if window_state is not None:
                    debug(f"Restoring {state_key}")
                    self.restoreState(window_state)
        if dock_val == b'yes':
            debug(f"Restoring journal to dock main window")
            self.journal_panel.dock_main_window()
        else:
            debug(f"Restoring journal to dock journal window")
            self.journal_panel.dock_journal_window(
                show=not self.config_panel.get_config().getboolean('options', 'system_tray_enabled'))


class JournalPanel(QDockWidget):

    def __init__(self, journal_watcher_task: JournalWatcherTask, max_journal_entries: int,
                 app_main_window: QMainWindow,
                 journal_main_window: QMainWindow):
        super().__init__(parent=None, flags=Qt.WindowFlags(Qt.WindowStaysOnTopHint))

        debug('JournalPanel','')
        self.setObjectName("journal-panel")
        self.is_docked_to_main = None

        self.app_main_window = app_main_window
        self.journal_main_window = journal_main_window

        self.setFloating(False)
        self.setFeatures(QDockWidget.DockWidgetFloatable | QDockWidget.DockWidgetMovable)

        self.table_view = JournalTableView(journal_watcher_task, max_journal_entries=max_journal_entries)

        # TODO add a test rules button that pops up a testing dialog with an input field.
        container = QWidget(self)
        layout = QVBoxLayout()
        container.setLayout(layout)
        title_container = QWidget(self)
        title_layout = QHBoxLayout()
        title_container.setLayout(title_layout)
        title_label = big_label(QLabel(tr("Recently notified")))
        title_layout.addWidget(title_label)

        spacer = QWidget()
        spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        title_layout.addWidget(spacer)

        def search_entries(text: str) -> None:
            self.scrolled_to_selected = None
            self.search_select_journal(text)
            go_next_button.setEnabled(self.scrolled_to_selected is not None)
            go_previous_button.setEnabled(self.scrolled_to_selected is not None)
            search_input.setFocus()

        search_input = QLineEdit()
        search_input.setFixedWidth(350)
        search_input.addAction(get_icon(ICON_SEARCH_JOURNAL), QLineEdit.LeadingPosition)
        search_input.setToolTip(tr("Incrementally search journal entries.\nSearches all fields."))
        search_input.textChanged.connect(search_entries)
        title_layout.addWidget(search_input)
        self.scrolled_to_selected = None

        go_next_button = transparent_button(QPushButton(get_icon(ICON_GO_NEXT), '', self))
        go_next_button.clicked.connect(partial(self.scroll_selected, 1))
        go_next_button.setEnabled(False)
        go_next_button.setToolTip(tr("Next match."))
        title_layout.addWidget(go_next_button)

        go_previous_button = transparent_button(QPushButton(get_icon(ICON_GO_PREVIOUS), '', self))
        go_previous_button.clicked.connect(partial(self.scroll_selected, -1))
        go_previous_button.setToolTip(tr("Previous match."))
        go_previous_button.setEnabled(False)
        title_layout.addWidget(go_previous_button)

        spacer = QWidget()
        spacer.setFixedWidth(10)
        spacer.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Preferred)
        title_layout.addWidget(spacer)

        self.dock_button = transparent_button(QPushButton(get_icon(ICON_UNDOCK), '', self))
        self.dock_button.setToolTip(tr("Dock/undock the Recently Notified panel"))
        title_layout.addWidget(self.dock_button)
        layout.addWidget(title_container)
        self.setWidget(container)

        self.dock_button.pressed.connect(self.switch_dock_state)

        self.setWindowTitle(tr("Recently notified"))
        self.setTitleBarWidget(QWidget())
        layout.addWidget(self.table_view)

        def top_level_changed(top_level: bool):
            pass

        self.topLevelChanged.connect(top_level_changed)
        self.setVisible(True)

    def get_selected_journal_entry(self):
        indexes = self.table_view.selectedIndexes()
        if indexes is None or len(indexes) == 0:
            return None
        return self.table_view.model().get_journal_entry(indexes[-1].row())

    def get_last_journal_entry(self):
        if self.table_view.model().rowCount() == 0:
            return None
        return self.table_view.model().get_journal_entry(self.table_view.model().rowCount() - 1)

    def search_select_journal(self, text: str):
        self.table_view.clearSelection()
        model = self.table_view.model()
        if text.strip() != '':
            for row_num in range(model.rowCount()):
                journal_entry = model.get_journal_entry(row_num)
                # Assume case insensitive if all text is in lower case.
                # Use an easy a format that is easy to pattern match: "'key=value', 'key=value'"
                fields_str = ', '.join((f"'{key}={str(value)}'" for key, value in journal_entry.items()))
                if text in fields_str.lower() if text.islower() else fields_str:
                    self.table_view.selectRow(row_num)
                    if self.scrolled_to_selected is None:
                        self.scrolled_to_selected = model.index(row_num, 0)
        if self.scrolled_to_selected is not None:
            self.table_view.scrollTo(self.scrolled_to_selected)

    def scroll_selected(self, direction: int):
        all_indexes = self.table_view.selectedIndexes()
        if len(all_indexes) == 0:
            return
        # Reduce the list of all selected row,col items to a list of one item for each row.
        row_start_selections = list({index.row(): index for index in all_indexes}.values())
        if self.scrolled_to_selected is None or self.scrolled_to_selected not in row_start_selections:
            self.scrolled_to_selected = row_start_selections[0]
        else:
            new_pos = (row_start_selections.index(self.scrolled_to_selected) + direction) % len(row_start_selections)
            self.scrolled_to_selected = row_start_selections[new_pos]
        self.table_view.scrollTo(self.scrolled_to_selected, QAbstractItemView.PositionAtCenter)

    def set_max_journal_entries(self, max_entries: int) -> None:
        self.table_view.model().set_max_journal_entries(max_entries)

    def switch_dock_state(self):
        # Switch between docked and undocked - use the system window manager.
        if self.parent() == self.journal_main_window:
            self.setParent(self.app_main_window)
            self.dock_main_window()
        else:
            self.setParent(self.journal_main_window)
            self.dock_journal_window()

    def dock_main_window(self):
        debug('dock_main_window')
        self.is_docked_to_main = True
        self.setFloating(True)
        self.journal_main_window.hide()
        self.dock_button.setIcon(get_icon(ICON_UNDOCK))
        self.app_main_window.addDockWidget(Qt.DockWidgetArea.TopDockWidgetArea, self)
        self.setFloating(False)
        self.app_main_window.setFocus()
        if self.journal_main_window.isVisible():
            self.journal_main_window.hide()

    def dock_journal_window(self, show: bool = True):
        debug('dock_journal_window')
        self.is_docked_to_main = False
        self.setFloating(True)
        self.dock_button.setIcon(get_icon(ICON_DOCK))
        self.journal_main_window.addDockWidget(Qt.DockWidgetArea.TopDockWidgetArea, self)
        self.setFloating(False)
        if show:
            self.journal_main_window.show()
            self.journal_main_window.setFocus()


class JournalMainWindow(QMainWindow):
    """
    I wanted an undockable component, but one with normal window decorations.
    So I've taken over the undocking process and reparent the floating window onto
    this alternate main window.
    """

    def __init__(self, app_main_window: MainWindow):
        super().__init__(parent=app_main_window)
        self.setObjectName('journal_main_window')
        self.app_main_window = app_main_window
        debug("JournalMainWindow visible", self.isVisible())

    def closeEvent(self, close_event: QCloseEvent) -> None:
        close_event.ignore()
        self.hide()
        self.app_main_window.journal_panel.dock_main_window()


class JournalTableView(QTableView):

    def __init__(self, journal_watcher_task: JournalWatcherTask, max_journal_entries: int):
        super().__init__()
        self.setToolTip(tr("Double click the row's message icon to view the complete journal entry."))
        self.setModel(JournalTableModel(max_journal_entries=max_journal_entries))
        self.max_entries = 100
        self.setDragDropOverwriteMode(False)
        self.resizeColumnsToContents()
        self.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.setSelectionMode(QAbstractItemView.MultiSelection)
        self.setColumnWidth(0, 8 * 14)
        self.setColumnWidth(1, 10 * 14)
        self.setColumnWidth(2, 10 * 14)
        self.setColumnWidth(3, 5 * 14)
        self.horizontalHeader().setSectionResizeMode(4, QHeaderView.Stretch)
        self.horizontalHeader().setDefaultAlignment(Qt.AlignLeft)
        self.setItemDelegate(JournalEntryDelegate(self.model()))
        # Cannot use xor!
        self.setEditTriggers(
            QAbstractItemView.AnyKeyPressed | QAbstractItemView.SelectedClicked | QAbstractItemView.CurrentChanged)
        self.setShowGrid(False)
        self.setIconSize(QSize(30, 30))

        def view_journal_entry(index: QModelIndex):
            entry_dialog = JournalEntryDialogPlain(self, self.model().get_journal_entry(index.row()))
            entry_dialog.show()

        self.doubleClicked.connect(view_journal_entry)

        def new_journal_entry(journal_entry):
            self.model().new_journal_entry(journal_entry)
            self.scrollToBottom()

        journal_watcher_task.signal_new_entry.connect(new_journal_entry)


class JournalTableModel(QStandardItemModel):

    def __init__(self, max_journal_entries: int):
        super().__init__(0, 5)
        self.max_journal_entries = max_journal_entries
        self.icon_cache = {}
        self.journal_entries = []
        self.setHorizontalHeaderLabels(
            [tr("Time"), tr("Host"), tr("Source"), tr("PID"), tr("Message")])

    def get_journal_entry(self, row: int):
        return self.journal_entries[row]

    def new_journal_entry(self, journal_entry):
        while self.rowCount() >= self.max_journal_entries:
            self.removeRow(0)
            self.journal_entries.pop(0)

        def align_right(item: QStandardItem):
            item.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
            return item

        def selectable(item: QStandardItem):
            item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled | Qt.ItemIsEditable)
            return item

        def setIcon(item: QStandardItem):
            priority = journal_entry['PRIORITY'] if 'PRIORITY' in journal_entry else Priority.NOTICE.value
            if not Priority.EMERGENCY.value <= priority <= Priority.DEBUG.value:
                priority = Priority.NOTICE.value
            notification_icon_name = NOTIFICATION_ICONS[Priority(priority)]
            if notification_icon_name in self.icon_cache:
                icon = self.icon_cache[notification_icon_name]
            else:
                icon = QIcon.fromTheme(notification_icon_name)
                self.icon_cache[notification_icon_name] = icon
            item.setIcon(icon)
            return item

        self.journal_entries.append(journal_entry)

        self.appendRow(
            [
                selectable(align_right(QStandardItem(f"{journal_entry['__REALTIME_TIMESTAMP']:%H:%M:%S}"))),
                selectable(QStandardItem(journal_entry['_HOSTNAME'])),
                # TODO smarter choice of source value
                selectable(QStandardItem(journal_entry['_COMM'] if '_COMM' in journal_entry else 'unknown')),
                # TODO smarter choice when _PID is not present.
                selectable(align_right(QStandardItem(str(journal_entry['_PID'] if '_PID' in journal_entry else '')))),
                setIcon(selectable(QStandardItem(journal_entry['MESSAGE'])))
            ])

    def set_max_journal_entries(self, max_entries: int) -> None:
        self.max_journal_entries = max_entries


class JournalEntryDelegate(QStyledItemDelegate):

    def createEditor(self, parent, option, index):
        line_edit = QLineEdit(parent)
        # Makes it behave line a normal readonly text entry (unlike making the whole table read only).
        line_edit.setReadOnly(True)
        return line_edit


class JournalEntryDialogPlain(QDialog):

    def __init__(self, parent, journal_entry):
        super().__init__(parent)

        self.setWindowTitle(tr(f"Journal Entry {journal_entry['__REALTIME_TIMESTAMP']}"))
        layout = QVBoxLayout()

        text_view = QTextEdit()
        text_view.setFont(QFontDatabase.systemFont(QFontDatabase.FixedFont))
        text_view.setReadOnly(True)
        text_view.setLineWrapMode(QTextEdit.LineWrapMode.NoWrap)
        text = tr(f"Journal Entry {journal_entry['__REALTIME_TIMESTAMP']}\n\n")
        for row, (k, v) in enumerate(sorted(list(journal_entry.items()))):
            text += f"{k:25}: {str(v)}\n"
        text_view.setText(text)

        layout.addWidget(text_view)

        self.setLayout(layout)
        self.setMinimumWidth(1000)
        self.setMinimumHeight(800)
        self.adjustSize()

        # .show() is non-modal, .exec() is modal
        self.show()

        def copy_to_clipboard():
            nonlocal floating_feedback_flip
            QGuiApplication.clipboard().setText(text_view.toPlainText())
            floating_copy_button.clearFocus()
            floating_copy_button.setIconSize(QSize(50, 50) if floating_feedback_flip else QSize(48, 48))
            floating_feedback_flip = not floating_feedback_flip
            floating_copy_button.repaint()

        floating_feedback_flip = True
        floating_copy_button = transparent_button(QPushButton(get_icon(ICON_COPY_TO_CLIPBOARD), '', self))
        floating_copy_button.setGeometry(self.width() - 75, 25, 40, 40)
        floating_copy_button.setIconSize(QSize(48, 48))
        floating_copy_button.setToolTip(tr("Copy to clipboard"))
        floating_copy_button.show()
        floating_copy_button.clicked.connect(copy_to_clipboard)


class DialogSingletonMixin:
    """
    A mixin that can augment a QDialog or QMessageBox with code to enforce a singleton UI.
    For example, it is used so that only ones settings editor can be active at a time.
    """
    _dialogs_map = {}
    debug = False

    def __init__(self) -> None:
        """Registers the concrete class as a singleton so it can be reused later."""
        super().__init__()
        class_name = self.__class__.__name__
        if class_name in DialogSingletonMixin._dialogs_map:
            raise TypeError(f"ERROR: More than one instance of {class_name} cannot exist.")
        if DialogSingletonMixin.debug:
            debug(f'SingletonDialog created for {class_name}') if debugging else None
        DialogSingletonMixin._dialogs_map[class_name] = self

    def closeEvent(self, event) -> None:
        """Subclasses that implement their own closeEvent must call this closeEvent to deregister the singleton"""
        class_name = self.__class__.__name__
        if DialogSingletonMixin.debug:
            debug(f'SingletonDialog remove {class_name}') if debugging else None
        del DialogSingletonMixin._dialogs_map[class_name]
        event.accept()

    def make_visible(self):
        """
        If the dialog exists(), call this to make it visible by raising it.
        Internal, used by the class method show_existing_dialog()
        """
        self.show()
        self.raise_()
        self.activateWindow()

    @classmethod
    def show_existing_dialog(cls: Type):
        """If the dialog exists(), call this to make it visible by raising it."""
        class_name = cls.__name__
        if DialogSingletonMixin.debug:
            debug(f'SingletonDialog show existing {class_name}') if debugging else None
        instance = DialogSingletonMixin._dialogs_map[class_name]
        instance.make_visible()

    @classmethod
    def exists(cls: Type) -> bool:
        """Returns true if the dialog has already been created."""
        class_name = cls.__name__
        if DialogSingletonMixin.debug:
            debug(
                f'SingletonDialog exists {class_name} {class_name in DialogSingletonMixin._dialogs_map}') if debugging else None
        return class_name in DialogSingletonMixin._dialogs_map


class AboutDialog(QMessageBox, DialogSingletonMixin):

    @staticmethod
    def invoke():
        if AboutDialog.exists():
            AboutDialog.show_existing_dialog()
        else:
            AboutDialog()

    def __init__(self):
        super().__init__()
        self.setWindowTitle(tr('About'))
        self.setTextFormat(Qt.AutoText)
        self.setText(tr('About jouno'))
        self.setInformativeText(tr(ABOUT_TEXT))
        self.setIcon(QMessageBox.Information)
        self.exec()


class HelpDialog(QDialog, DialogSingletonMixin):

    @staticmethod
    def invoke():
        if HelpDialog.exists():
            HelpDialog.show_existing_dialog()
        else:
            HelpDialog()

    def __init__(self):
        super().__init__()
        self.setWindowTitle(tr('Help'))
        layout = QVBoxLayout()
        markdown_view = QTextEdit()
        markdown_view.setReadOnly(True)
        markdown_view.setMarkdown(__doc__)
        layout.addWidget(markdown_view)
        self.setLayout(layout)
        # TODO maybe compute a minimum from the actual screen size
        self.setMinimumWidth(1400)
        self.setMinimumHeight(1000)
        # .show() is non-modal, .exec() is modal
        self.make_visible()


class ContextMenu(QMenu):

    def __init__(self, about_action=None, help_action=None, listen_action=None, quit_action=None) -> None:
        super().__init__()

        self.play_pause_action = self.addAction(
            ICON_CONTEXT_MENU_LISTENING_DISABLE,
            tr('Pause'),
            listen_action)
        self.addAction(get_icon(ICON_HELP_ABOUT),
                       tr('About'),
                       about_action)
        self.addAction(get_icon(ICON_HELP_CONTENTS),
                       tr('Help'),
                       help_action)
        self.addSeparator()
        self.addAction(get_icon(ICON_APPLICATION_EXIT),
                       tr('Quit'),
                       quit_action)


def exception_handler(e_type, e_value, e_traceback):
    """Overarching error handler in case something unexpected happens."""
    error("\n", ''.join(traceback.format_exception(e_type, e_value, e_traceback)))
    alert = QMessageBox()
    alert.setText(tr('Error: {}').format(''.join(traceback.format_exception_only(e_type, e_value))))
    alert.setInformativeText(tr('Unexpected error'))
    alert.setDetailedText(
        tr('Details: {}').format(''.join(traceback.format_exception(e_type, e_value, e_traceback))))
    alert.setIcon(QMessageBox.Critical)
    alert.exec()
    QApplication.quit()


def install_as_desktop_application(uninstall: bool = False):
    """Self install this script in the current Linux user's bin directory and desktop applications->settings menu."""
    desktop_dir = Path.home().joinpath('.local', 'share', 'applications')
    icon_dir = Path.home().joinpath('.local', 'share', 'icons')
    if not desktop_dir.exists():
        error(f"No desktop directory is present:{desktop_dir.as_posix()}"
              " Cannot proceed - is this a non-standard desktop?")
        return

    bin_dir = Path.home().joinpath('bin')
    if not bin_dir.is_dir():
        warning("creating:{bin_dir.as_posix()}")
        os.mkdir(bin_dir)

    if not icon_dir.is_dir():
        warning("creating:{icon_dir.as_posix()}")
        os.mkdir(icon_dir)

    installed_script_path = bin_dir.joinpath("jouno")
    desktop_definition_path = desktop_dir.joinpath("jouno.desktop")
    icon_path = icon_dir.joinpath("jouno.png")

    if uninstall:
        os.remove(installed_script_path)
        info(f'removed {installed_script_path.as_posix()}')
        os.remove(desktop_definition_path)
        info(f'removed {desktop_definition_path.as_posix()}')
        os.remove(icon_path)
        info(f'removed {icon_path.as_posix()}')
        return

    if installed_script_path.exists():
        warning(f"skipping installation of {installed_script_path.as_posix()}, it is already present.")
    else:
        source = open(__file__).read()
        source = source.replace("#!/usr/bin/python3", '#!' + sys.executable)
        info(f'creating {installed_script_path.as_posix()}')
        open(installed_script_path, 'w').write(source)
        info(f'chmod u+rwx {installed_script_path.as_posix()}')
        os.chmod(installed_script_path, stat.S_IRWXU)

    if desktop_definition_path.exists():
        warning(f"skipping installation of {desktop_definition_path.as_posix()}, it is already present.")
    else:
        info(f'creating {desktop_definition_path.as_posix()}')
        desktop_definition = textwrap.dedent(f"""
            [Desktop Entry]
            Type=Application
            Exec={installed_script_path.as_posix()}
            Name=jouno
            GenericName=juno
            Comment=A Systemd-Journal to Freedesktop-Notifications forwarder.
            Icon={icon_path.as_posix()}
            Categories=Qt;System;Monitor;System;
            """)
        open(desktop_definition_path, 'w').write(desktop_definition)

    if icon_path.exists():
        warning(f"skipping installation of {icon_path.as_posix()}, it is already present.")
    else:
        info(f'creating {icon_path.as_posix()}')
        create_pixmap_from_svg_bytes(ICON_JOUNO).save(icon_path.as_posix())

    info('installation complete. Your desktop->applications->system should now contain jouno')


def parse_args():
    args = sys.argv[1:]
    parser = argparse.ArgumentParser(
        description="A Systemd-Journal to Freedesktop-Notifications forwarder",
        formatter_class=argparse.RawTextHelpFormatter)
    parser.epilog = textwrap.dedent(f"""
            """)
    parser.add_argument('--detailed-help', default=False, action='store_true',
                        help='Detailed help (in markdown format).')
    parser.add_argument('--debug', default=False, action='store_true', help='enable debug output to stdout')
    parser.add_argument('--install', action='store_true',
                        help="installs the jouno application in the current user's path and desktop application menu.")
    parser.add_argument('--uninstall', action='store_true',
                        help='uninstalls the jouno application menu file and script for the current user.')
    parsed_args = parser.parse_args(args=args)
    if parsed_args.install:
        install_as_desktop_application()
        sys.exit()
    if parsed_args.uninstall:
        install_as_desktop_application(uninstall=True)
        sys.exit()
    if parsed_args.detailed_help:
        print(__doc__)
        sys.exit()


def main():
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    sys.excepthook = exception_handler
    app = QApplication(sys.argv)
    parse_args()
    MainWindow(app)


if __name__ == '__main__':
    main()
